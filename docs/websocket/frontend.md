## クライアントサイド WebSocket 導入計画（詳細）

### 1. 基本設計方針

- **WebSocket エンドポイント:**  
  `ws(s)://{サーバー}/ws?token={JWT}`  
  JWT は必ずクエリパラメータで付与

- **接続管理:**

  - アクティブなタブ/ウインドウ 1 つだけが WebSocket に接続
  - タブ切り替え・非アクティブ時は接続を切り、再アクティブ化時に再接続
  - 複数デバイス・ブラウザでの同時ログイン・接続もサーバ側は許容（サイドエフェクト設計済み）

- **将来的なイベント追加:**
  - 「チャンネルへの追加」など、サーバからクライアントへの新規イベントは今後も増える前提で、拡張しやすいテーブル駆動/dispatcher 設計とする

---

### 2. 実装タスク・ステップ

1. **WebSocket コアユーティリティ実装**

   - JWT・クエリパラメータで動的に接続構築
   - ハートビートや自動リトライ（失敗・切断時の再接続）
   - クローズ時の clean-up

2. **アクティブタブ判定ロジック**

   - `visibilitychange`イベント等で管理し、アクティブ復帰時は即再接続
   - 必要に応じてタブ間通信（BroadcastChannel 等）で「どのタブが保持役か」同期することで多重接続を抑制  
     → 切替もシームレス&リアルタイムで受信を継続

3. **購読チャンネル管理**

   - 有効なルームだけ`join_channel`/`leave_channel`を明示送信する
   - UI 状態変更時（タブ遷移・チャンネル切替）で購読を即変更

4. **イベント受信・type 分岐ロジック**

   - `type`ごとにハンドラ関数定義（例: new_message, unread_count, pin_created, typing, 追加イベント等拡張も容易に）
   - payload は型安全な形で各 store/UI に dispatch

5. **メッセージ送信 API**

   - post_message、typing 等は型付きでラップし送信

6. **エラー・ack ハンドリング**

   - type=error, type=ack を全 API でハンドリング
   - サーバ側未知イベント時なども考慮する共通 UI 通知(リトライ UI, トースト等)

7. **TypeScript 型定義整備**
   - event.go の構造体定義を TS へマッピング（type 安全性担保）

---

### 3. 今後のタスク追加想定（イベント増加等）

- サーバ実装拡張に合わせ、event type ディスパッチャー（テーブル定義等）に新イベントハンドラを追加できる設計
- 例：チャンネル追加通知イベント
  ```
  { type: "channel_added", payload: {...} }
  ```
  フック先の store/UI を柔軟に追加できる形を維持

---

### 4. 注意事項・依頼事項

- WebSocket 接続の統一的管理（アクティブタブのみ・切断と復帰の適切な連携）は UI フレームワーク頼りにならない一元管理を意識
- 将来的な追加イベント時、サーバ側 schema 設計変更があれば都度教えてください（TS 型/受信ハンドラ拡張を即対応可にします）

---

### 次アクション（推奨）

1. WebSocket 管理ファイル（例: `frontend/src/lib/ws.ts`）の新規設計・実装開始
2. 型定義ファイルの準備（サーバの event 定義に追従）
3. 最小限の検証（接続～ join_channel にて新着受信確認）
