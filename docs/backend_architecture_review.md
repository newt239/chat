# バックエンドアーキテクチャのレビューと改善提案

## 1. はじめに

このドキュメントは、現在のバックエンド実装をクリーンアーキテクチャの原則に基づきレビューし、発見された技術的負債、不要・冗長なコードの問題点を指摘し、改善策を提案するものです。

全体として、プロジェクトのディレクトリ構造はクリーンアーキテクチャ（`adapter`, `usecase`, `domain`, `infrastructure`）を意識しており、関心の分離への取り組みが見られます。しかし、詳細な実装レベルでいくつかの課題が確認されました。これらの課題を解決することで、コードの堅牢性、保守性、拡張性を大幅に向上させることができます。

## 2. レイヤーごとの分析と問題点

### 2.1. Domainレイヤー

ドメイン層はビジネスの核となるルールとエンティティを定義する、アーキテクチャの中心です。

**問題点: 貧血なドメインモデル (Anemic Domain Model)**

- `internal/domain/entity` 以下のエンティティ（例: `Channel`）は、単なるデータ構造となっており、自身の状態を操作・保護するためのビジネスロジック（振る舞い）を持っていません。
- 例えば、チャンネル名のバリデーションや状態遷移のルールなどが、エンティティの外部（主にUsecase層）に記述されています。これにより、ビジネスルールが複数の箇所に散在し、一貫性の維持が困難になります。
- エンティティを生成するコンストラクタがないため、必須項目が欠落した不正な状態のオブジェクトが生成されるリスクがあります。

**改善提案:**

- **エンティティに振る舞いを持たせる:** バリデーションロジックや状態を変更するメソッドをエンティティ自身に追加します。
  ```go
  // 例: Channelエンティティ
  func (c *Channel) ChangeName(newName string) error {
      if newName == "" {
          return errors.New("channel name cannot be empty")
      }
      c.Name = newName
      c.UpdatedAt = time.Now()
      return nil
  }
  ```
- **コンストラクタを導入する:** エンティティの不変条件（常に満たすべきルール）を保証するため、オブジェクト生成時にバリデーションを行うファクトリ関数を定義します。
  ```go
  func NewChannel(name, workspaceID, userID string, isPrivate bool) (*Channel, error) {
      if name == "" {
          return nil, errors.New("channel name is required")
      }
      // ...その他のバリデーション
      return &Channel{
          ID:          uuid.NewString(),
          Name:        name,
          WorkspaceID: workspaceID,
          CreatedBy:   userID,
          IsPrivate:   isPrivate,
          // ...
      }, nil
  }
  ```

### 2.2. Repository (Interface & Implementation)

リポジトリはドメイン層とデータ永続化層の間の架け橋となる重要な責務を担います。

**問題点1: 肥大化したインターフェースと実装**

- `ChannelRepository` が、チャンネル自身の永続化だけでなく、`ChannelMember` に関する操作（追加、削除、検索など）も担当しています。
- これは **インターフェース分離の原則** に反しており、`ChannelRepository` の責務が単一でなくなっています。

**改善提案:**

- `ChannelMemberRepository` のように、エンティティごとにリポジトリを分割します。これにより、各リポジトリの責務が明確になり、利用側（Usecase）も必要なインターフェースにのみ依存できます。

**問題点2: リポジトリ実装内での責務逸脱**

- `persistence/channel_repository.go` の各メソッドで、`parseUUID` のような入力値の検証が行われています。リポジトリの責務は永続化であり、入力値のフォーマット検証はUsecaseやドメインの入り口で行うべきです。
- `Update` メソッドが `map[string]interface{}` を使っており、タイプセーフではありません。

**改善提案:**

- UUIDのパースのような検証ロジックはリポジトリから削除し、Usecase層に移管します。
- 更新処理は、GORMの `Select` を使うなど、よりタイプセーフで意図が明確な方法に修正します。

### 2.3. Usecaseレイヤー

Usecase層は、アプリケーション固有のビジネスルールを実装し、ドメインエンティティやリポジトリを協調させてタスクを達成します。

**問題点1: トランザクション管理の欠如**

- `CreateChannel` のUsecaseでは、チャンネル作成とメンバー追加という2つの書き込み処理が行われていますが、これらが単一のトランザクションとして管理されていません。片方の処理が失敗した場合、データが不整合な状態になる可能性があります。

**改善提案:**

- **Unit of Work パターン** を導入し、Usecase層でトランザクションの境界を明示的に管理します。`registry` でトランザクション管理オブジェクトを生成し、Usecaseに注入する構成が考えられます。

**問題点2: 権限チェックロジックの散在**

- `if member.Role != entity.WorkspaceRoleOwner && member.Role != entity.WorkspaceRoleAdmin` のような権限チェックロジックがUsecase内に直接記述されています。

**改善提案:**

- このようなロジックはドメインの知識であるため、ドメインサービスやエンティティ（例: `WorkspaceMember` の `CanCreateChannel()` メソッド）にカプセル化します。Usecaseはそれを呼び出すだけ、という形が理想です。

### 2.4. Infrastructureレイヤー

インフラ層は、DB接続や外部API連携など、技術的な詳細をすべてカプセル化します。

**問題点: アプリケーション起動時の自動マイグレーション**

- `InitDB` 関数内で `gorm.AutoMigrate` が実行されています。これは開発中は便利ですが、本番環境で実行されると、意図しないスキーマ変更やデータ損失を引き起こす可能性があり、非常に危険です。

**改善提案:**

- `AutoMigrate` の呼び出しをコードから完全に削除します。
- `atlas.hcl` が存在することから、Atlasのような専用のマイグレーションツールを使用し、マイグレーションはアプリケーションの実行とは独立した、開発者が意図したタイミングで実行する運用を徹底します。

## 3. 総括と推奨される対応順

現状のアーキテクチャは良い骨格を持っていますが、いくつかの重要な技術的負債を抱えています。特に **「貧血なドメインモデル」** は、アプリケーションの複雑性が増すにつれて、保守性を著しく低下させる根本的な問題です。

以下の順序で改善に取り組むことを推奨します。

1.  **[最優先] 自動マイグレーションの削除:** 本番環境での事故を未然に防ぐため、直ちに対応すべきです。
2.  **リポジトリの責務分割:** `ChannelRepository` の肥大化を解消し、コードの見通しを良くします。これは比較的影響範囲が少なく、着手しやすい改善です。
3.  **Usecaseのトランザクション管理:** データの整合性を保証するために重要です。Unit of Workパターンの導入を検討します。
4.  **[長期的] ドメインモデルの強化:** 最も重要かつ根本的な改善です。新しい機能を追加する際や、既存機能を改修する際に、ビジネスロジックをエンティティに集約していくアプローチを継続的に行います。

これらの改善を通じて、よりクリーンで、変化に強く、スケールしやすいバックエンドシステムを構築できると考えます。
