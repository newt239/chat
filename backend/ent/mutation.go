// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/newt239/chat/ent/attachment"
	"github.com/newt239/chat/ent/channel"
	"github.com/newt239/chat/ent/channelmember"
	"github.com/newt239/chat/ent/channelreadstate"
	"github.com/newt239/chat/ent/message"
	"github.com/newt239/chat/ent/messagebookmark"
	"github.com/newt239/chat/ent/messagegroupmention"
	"github.com/newt239/chat/ent/messagelink"
	"github.com/newt239/chat/ent/messagepin"
	"github.com/newt239/chat/ent/messagereaction"
	"github.com/newt239/chat/ent/messageusermention"
	"github.com/newt239/chat/ent/predicate"
	"github.com/newt239/chat/ent/session"
	"github.com/newt239/chat/ent/systemmessage"
	"github.com/newt239/chat/ent/threadmetadata"
	"github.com/newt239/chat/ent/threadreadstate"
	"github.com/newt239/chat/ent/user"
	"github.com/newt239/chat/ent/usergroup"
	"github.com/newt239/chat/ent/usergroupmember"
	"github.com/newt239/chat/ent/userthreadfollow"
	"github.com/newt239/chat/ent/workspace"
	"github.com/newt239/chat/ent/workspacemember"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment          = "Attachment"
	TypeChannel             = "Channel"
	TypeChannelMember       = "ChannelMember"
	TypeChannelReadState    = "ChannelReadState"
	TypeMessage             = "Message"
	TypeMessageBookmark     = "MessageBookmark"
	TypeMessageGroupMention = "MessageGroupMention"
	TypeMessageLink         = "MessageLink"
	TypeMessagePin          = "MessagePin"
	TypeMessageReaction     = "MessageReaction"
	TypeMessageUserMention  = "MessageUserMention"
	TypeSession             = "Session"
	TypeSystemMessage       = "SystemMessage"
	TypeThreadMetadata      = "ThreadMetadata"
	TypeThreadReadState     = "ThreadReadState"
	TypeUser                = "User"
	TypeUserGroup           = "UserGroup"
	TypeUserGroupMember     = "UserGroupMember"
	TypeUserThreadFollow    = "UserThreadFollow"
	TypeWorkspace           = "Workspace"
	TypeWorkspaceMember     = "WorkspaceMember"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	file_name       *string
	mime_type       *string
	size_bytes      *int64
	addsize_bytes   *int64
	storage_key     *string
	status          *string
	uploaded_at     *time.Time
	expires_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	message         *uuid.UUID
	clearedmessage  bool
	uploader        *uuid.UUID
	cleareduploader bool
	channel         *uuid.UUID
	clearedchannel  bool
	done            bool
	oldValue        func(context.Context) (*Attachment, error)
	predicates      []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileName sets the "file_name" field.
func (m *AttachmentMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *AttachmentMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *AttachmentMutation) ResetFileName() {
	m.file_name = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AttachmentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AttachmentMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *AttachmentMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *AttachmentMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *AttachmentMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *AttachmentMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *AttachmentMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetStorageKey sets the "storage_key" field.
func (m *AttachmentMutation) SetStorageKey(s string) {
	m.storage_key = &s
}

// StorageKey returns the value of the "storage_key" field in the mutation.
func (m *AttachmentMutation) StorageKey() (r string, exists bool) {
	v := m.storage_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageKey returns the old "storage_key" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldStorageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageKey: %w", err)
	}
	return oldValue.StorageKey, nil
}

// ResetStorageKey resets all changes to the "storage_key" field.
func (m *AttachmentMutation) ResetStorageKey() {
	m.storage_key = nil
}

// SetStatus sets the "status" field.
func (m *AttachmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AttachmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AttachmentMutation) ResetStatus() {
	m.status = nil
}

// SetUploadedAt sets the "uploaded_at" field.
func (m *AttachmentMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the value of the "uploaded_at" field in the mutation.
func (m *AttachmentMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old "uploaded_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUploadedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ClearUploadedAt clears the value of the "uploaded_at" field.
func (m *AttachmentMutation) ClearUploadedAt() {
	m.uploaded_at = nil
	m.clearedFields[attachment.FieldUploadedAt] = struct{}{}
}

// UploadedAtCleared returns if the "uploaded_at" field was cleared in this mutation.
func (m *AttachmentMutation) UploadedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUploadedAt]
	return ok
}

// ResetUploadedAt resets all changes to the "uploaded_at" field.
func (m *AttachmentMutation) ResetUploadedAt() {
	m.uploaded_at = nil
	delete(m.clearedFields, attachment.FieldUploadedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *AttachmentMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AttachmentMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AttachmentMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[attachment.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AttachmentMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AttachmentMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, attachment.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *AttachmentMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *AttachmentMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *AttachmentMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *AttachmentMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *AttachmentMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetUploaderID sets the "uploader" edge to the User entity by id.
func (m *AttachmentMutation) SetUploaderID(id uuid.UUID) {
	m.uploader = &id
}

// ClearUploader clears the "uploader" edge to the User entity.
func (m *AttachmentMutation) ClearUploader() {
	m.cleareduploader = true
}

// UploaderCleared reports if the "uploader" edge to the User entity was cleared.
func (m *AttachmentMutation) UploaderCleared() bool {
	return m.cleareduploader
}

// UploaderID returns the "uploader" edge ID in the mutation.
func (m *AttachmentMutation) UploaderID() (id uuid.UUID, exists bool) {
	if m.uploader != nil {
		return *m.uploader, true
	}
	return
}

// UploaderIDs returns the "uploader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploaderID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) UploaderIDs() (ids []uuid.UUID) {
	if id := m.uploader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploader resets all changes to the "uploader" edge.
func (m *AttachmentMutation) ResetUploader() {
	m.uploader = nil
	m.cleareduploader = false
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *AttachmentMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *AttachmentMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *AttachmentMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *AttachmentMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *AttachmentMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.file_name != nil {
		fields = append(fields, attachment.FieldFileName)
	}
	if m.mime_type != nil {
		fields = append(fields, attachment.FieldMimeType)
	}
	if m.size_bytes != nil {
		fields = append(fields, attachment.FieldSizeBytes)
	}
	if m.storage_key != nil {
		fields = append(fields, attachment.FieldStorageKey)
	}
	if m.status != nil {
		fields = append(fields, attachment.FieldStatus)
	}
	if m.uploaded_at != nil {
		fields = append(fields, attachment.FieldUploadedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, attachment.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldFileName:
		return m.FileName()
	case attachment.FieldMimeType:
		return m.MimeType()
	case attachment.FieldSizeBytes:
		return m.SizeBytes()
	case attachment.FieldStorageKey:
		return m.StorageKey()
	case attachment.FieldStatus:
		return m.Status()
	case attachment.FieldUploadedAt:
		return m.UploadedAt()
	case attachment.FieldExpiresAt:
		return m.ExpiresAt()
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldFileName:
		return m.OldFileName(ctx)
	case attachment.FieldMimeType:
		return m.OldMimeType(ctx)
	case attachment.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case attachment.FieldStorageKey:
		return m.OldStorageKey(ctx)
	case attachment.FieldStatus:
		return m.OldStatus(ctx)
	case attachment.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	case attachment.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case attachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case attachment.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case attachment.FieldStorageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageKey(v)
		return nil
	case attachment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case attachment.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	case attachment.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, attachment.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldUploadedAt) {
		fields = append(fields, attachment.FieldUploadedAt)
	}
	if m.FieldCleared(attachment.FieldExpiresAt) {
		fields = append(fields, attachment.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldUploadedAt:
		m.ClearUploadedAt()
		return nil
	case attachment.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldFileName:
		m.ResetFileName()
		return nil
	case attachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	case attachment.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case attachment.FieldStorageKey:
		m.ResetStorageKey()
		return nil
	case attachment.FieldStatus:
		m.ResetStatus()
		return nil
	case attachment.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	case attachment.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.message != nil {
		edges = append(edges, attachment.EdgeMessage)
	}
	if m.uploader != nil {
		edges = append(edges, attachment.EdgeUploader)
	}
	if m.channel != nil {
		edges = append(edges, attachment.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeUploader:
		if id := m.uploader; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmessage {
		edges = append(edges, attachment.EdgeMessage)
	}
	if m.cleareduploader {
		edges = append(edges, attachment.EdgeUploader)
	}
	if m.clearedchannel {
		edges = append(edges, attachment.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeMessage:
		return m.clearedmessage
	case attachment.EdgeUploader:
		return m.cleareduploader
	case attachment.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ClearMessage()
		return nil
	case attachment.EdgeUploader:
		m.ClearUploader()
		return nil
	case attachment.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ResetMessage()
		return nil
	case attachment.EdgeUploader:
		m.ResetUploader()
		return nil
	case attachment.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	description        *string
	is_private         *bool
	channel_type       *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	workspace          *uuid.UUID
	clearedworkspace   bool
	created_by         *uuid.UUID
	clearedcreated_by  bool
	members            map[uuid.UUID]struct{}
	removedmembers     map[uuid.UUID]struct{}
	clearedmembers     bool
	messages           map[uuid.UUID]struct{}
	removedmessages    map[uuid.UUID]struct{}
	clearedmessages    bool
	attachments        map[uuid.UUID]struct{}
	removedattachments map[uuid.UUID]struct{}
	clearedattachments bool
	read_states        map[uuid.UUID]struct{}
	removedread_states map[uuid.UUID]struct{}
	clearedread_states bool
	done               bool
	oldValue           func(context.Context) (*Channel, error)
	predicates         []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id uuid.UUID) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChannelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[channel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChannelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[channel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, channel.FieldDescription)
}

// SetIsPrivate sets the "is_private" field.
func (m *ChannelMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *ChannelMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *ChannelMutation) ResetIsPrivate() {
	m.is_private = nil
}

// SetChannelType sets the "channel_type" field.
func (m *ChannelMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *ChannelMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldChannelType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ClearChannelType clears the value of the "channel_type" field.
func (m *ChannelMutation) ClearChannelType() {
	m.channel_type = nil
	m.clearedFields[channel.FieldChannelType] = struct{}{}
}

// ChannelTypeCleared returns if the "channel_type" field was cleared in this mutation.
func (m *ChannelMutation) ChannelTypeCleared() bool {
	_, ok := m.clearedFields[channel.FieldChannelType]
	return ok
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *ChannelMutation) ResetChannelType() {
	m.channel_type = nil
	delete(m.clearedFields, channel.FieldChannelType)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkspaceID sets the "workspace" edge to the Workspace entity by id.
func (m *ChannelMutation) SetWorkspaceID(id uuid.UUID) {
	m.workspace = &id
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *ChannelMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *ChannelMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceID returns the "workspace" edge ID in the mutation.
func (m *ChannelMutation) WorkspaceID() (id uuid.UUID, exists bool) {
	if m.workspace != nil {
		return *m.workspace, true
	}
	return
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *ChannelMutation) WorkspaceIDs() (ids []uuid.UUID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *ChannelMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ChannelMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ChannelMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ChannelMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ChannelMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ChannelMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ChannelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddMemberIDs adds the "members" edge to the ChannelMember entity by ids.
func (m *ChannelMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the ChannelMember entity.
func (m *ChannelMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the ChannelMember entity was cleared.
func (m *ChannelMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the ChannelMember entity by IDs.
func (m *ChannelMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the ChannelMember entity.
func (m *ChannelMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ChannelMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ChannelMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ChannelMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ChannelMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ChannelMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ChannelMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ChannelMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ChannelMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ChannelMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *ChannelMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *ChannelMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *ChannelMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *ChannelMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *ChannelMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *ChannelMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *ChannelMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddReadStateIDs adds the "read_states" edge to the ChannelReadState entity by ids.
func (m *ChannelMutation) AddReadStateIDs(ids ...uuid.UUID) {
	if m.read_states == nil {
		m.read_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.read_states[ids[i]] = struct{}{}
	}
}

// ClearReadStates clears the "read_states" edge to the ChannelReadState entity.
func (m *ChannelMutation) ClearReadStates() {
	m.clearedread_states = true
}

// ReadStatesCleared reports if the "read_states" edge to the ChannelReadState entity was cleared.
func (m *ChannelMutation) ReadStatesCleared() bool {
	return m.clearedread_states
}

// RemoveReadStateIDs removes the "read_states" edge to the ChannelReadState entity by IDs.
func (m *ChannelMutation) RemoveReadStateIDs(ids ...uuid.UUID) {
	if m.removedread_states == nil {
		m.removedread_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.read_states, ids[i])
		m.removedread_states[ids[i]] = struct{}{}
	}
}

// RemovedReadStates returns the removed IDs of the "read_states" edge to the ChannelReadState entity.
func (m *ChannelMutation) RemovedReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.removedread_states {
		ids = append(ids, id)
	}
	return
}

// ReadStatesIDs returns the "read_states" edge IDs in the mutation.
func (m *ChannelMutation) ReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.read_states {
		ids = append(ids, id)
	}
	return
}

// ResetReadStates resets all changes to the "read_states" edge.
func (m *ChannelMutation) ResetReadStates() {
	m.read_states = nil
	m.clearedread_states = false
	m.removedread_states = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, channel.FieldDescription)
	}
	if m.is_private != nil {
		fields = append(fields, channel.FieldIsPrivate)
	}
	if m.channel_type != nil {
		fields = append(fields, channel.FieldChannelType)
	}
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldName:
		return m.Name()
	case channel.FieldDescription:
		return m.Description()
	case channel.FieldIsPrivate:
		return m.IsPrivate()
	case channel.FieldChannelType:
		return m.ChannelType()
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldDescription:
		return m.OldDescription(ctx)
	case channel.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case channel.FieldChannelType:
		return m.OldChannelType(ctx)
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channel.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case channel.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldDescription) {
		fields = append(fields, channel.FieldDescription)
	}
	if m.FieldCleared(channel.FieldChannelType) {
		fields = append(fields, channel.FieldChannelType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldDescription:
		m.ClearDescription()
		return nil
	case channel.FieldChannelType:
		m.ClearChannelType()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldDescription:
		m.ResetDescription()
		return nil
	case channel.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case channel.FieldChannelType:
		m.ResetChannelType()
		return nil
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.workspace != nil {
		edges = append(edges, channel.EdgeWorkspace)
	}
	if m.created_by != nil {
		edges = append(edges, channel.EdgeCreatedBy)
	}
	if m.members != nil {
		edges = append(edges, channel.EdgeMembers)
	}
	if m.messages != nil {
		edges = append(edges, channel.EdgeMessages)
	}
	if m.attachments != nil {
		edges = append(edges, channel.EdgeAttachments)
	}
	if m.read_states != nil {
		edges = append(edges, channel.EdgeReadStates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case channel.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case channel.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeReadStates:
		ids := make([]ent.Value, 0, len(m.read_states))
		for id := range m.read_states {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmembers != nil {
		edges = append(edges, channel.EdgeMembers)
	}
	if m.removedmessages != nil {
		edges = append(edges, channel.EdgeMessages)
	}
	if m.removedattachments != nil {
		edges = append(edges, channel.EdgeAttachments)
	}
	if m.removedread_states != nil {
		edges = append(edges, channel.EdgeReadStates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeReadStates:
		ids := make([]ent.Value, 0, len(m.removedread_states))
		for id := range m.removedread_states {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedworkspace {
		edges = append(edges, channel.EdgeWorkspace)
	}
	if m.clearedcreated_by {
		edges = append(edges, channel.EdgeCreatedBy)
	}
	if m.clearedmembers {
		edges = append(edges, channel.EdgeMembers)
	}
	if m.clearedmessages {
		edges = append(edges, channel.EdgeMessages)
	}
	if m.clearedattachments {
		edges = append(edges, channel.EdgeAttachments)
	}
	if m.clearedread_states {
		edges = append(edges, channel.EdgeReadStates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeWorkspace:
		return m.clearedworkspace
	case channel.EdgeCreatedBy:
		return m.clearedcreated_by
	case channel.EdgeMembers:
		return m.clearedmembers
	case channel.EdgeMessages:
		return m.clearedmessages
	case channel.EdgeAttachments:
		return m.clearedattachments
	case channel.EdgeReadStates:
		return m.clearedread_states
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	case channel.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case channel.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case channel.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case channel.EdgeMembers:
		m.ResetMembers()
		return nil
	case channel.EdgeMessages:
		m.ResetMessages()
		return nil
	case channel.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case channel.EdgeReadStates:
		m.ResetReadStates()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChannelMemberMutation represents an operation that mutates the ChannelMember nodes in the graph.
type ChannelMemberMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	role           *string
	joined_at      *time.Time
	clearedFields  map[string]struct{}
	channel        *uuid.UUID
	clearedchannel bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ChannelMember, error)
	predicates     []predicate.ChannelMember
}

var _ ent.Mutation = (*ChannelMemberMutation)(nil)

// channelmemberOption allows management of the mutation configuration using functional options.
type channelmemberOption func(*ChannelMemberMutation)

// newChannelMemberMutation creates new mutation for the ChannelMember entity.
func newChannelMemberMutation(c config, op Op, opts ...channelmemberOption) *ChannelMemberMutation {
	m := &ChannelMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelMemberID sets the ID field of the mutation.
func withChannelMemberID(id uuid.UUID) channelmemberOption {
	return func(m *ChannelMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelMember
		)
		m.oldValue = func(ctx context.Context) (*ChannelMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelMember sets the old ChannelMember of the mutation.
func withChannelMember(node *ChannelMember) channelmemberOption {
	return func(m *ChannelMemberMutation) {
		m.oldValue = func(context.Context) (*ChannelMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelMember entities.
func (m *ChannelMemberMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMemberMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMemberMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *ChannelMemberMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *ChannelMemberMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ChannelMember entity.
// If the ChannelMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMemberMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ChannelMemberMutation) ResetRole() {
	m.role = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *ChannelMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *ChannelMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the ChannelMember entity.
// If the ChannelMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *ChannelMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *ChannelMemberMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelMemberMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelMemberMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *ChannelMemberMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelMemberMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelMemberMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChannelMemberMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChannelMemberMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelMemberMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ChannelMemberMutation builder.
func (m *ChannelMemberMutation) Where(ps ...predicate.ChannelMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelMember).
func (m *ChannelMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMemberMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, channelmember.FieldRole)
	}
	if m.joined_at != nil {
		fields = append(fields, channelmember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelmember.FieldRole:
		return m.Role()
	case channelmember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelmember.FieldRole:
		return m.OldRole(ctx)
	case channelmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelmember.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case channelmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChannelMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChannelMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMemberMutation) ResetField(name string) error {
	switch name {
	case channelmember.FieldRole:
		m.ResetRole()
		return nil
	case channelmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel != nil {
		edges = append(edges, channelmember.EdgeChannel)
	}
	if m.user != nil {
		edges = append(edges, channelmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelmember.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case channelmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel {
		edges = append(edges, channelmember.EdgeChannel)
	}
	if m.cleareduser {
		edges = append(edges, channelmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case channelmember.EdgeChannel:
		return m.clearedchannel
	case channelmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMemberMutation) ClearEdge(name string) error {
	switch name {
	case channelmember.EdgeChannel:
		m.ClearChannel()
		return nil
	case channelmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMemberMutation) ResetEdge(name string) error {
	switch name {
	case channelmember.EdgeChannel:
		m.ResetChannel()
		return nil
	case channelmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelMember edge %s", name)
}

// ChannelReadStateMutation represents an operation that mutates the ChannelReadState nodes in the graph.
type ChannelReadStateMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	last_read_at   *time.Time
	clearedFields  map[string]struct{}
	channel        *uuid.UUID
	clearedchannel bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ChannelReadState, error)
	predicates     []predicate.ChannelReadState
}

var _ ent.Mutation = (*ChannelReadStateMutation)(nil)

// channelreadstateOption allows management of the mutation configuration using functional options.
type channelreadstateOption func(*ChannelReadStateMutation)

// newChannelReadStateMutation creates new mutation for the ChannelReadState entity.
func newChannelReadStateMutation(c config, op Op, opts ...channelreadstateOption) *ChannelReadStateMutation {
	m := &ChannelReadStateMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelReadState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelReadStateID sets the ID field of the mutation.
func withChannelReadStateID(id uuid.UUID) channelreadstateOption {
	return func(m *ChannelReadStateMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelReadState
		)
		m.oldValue = func(ctx context.Context) (*ChannelReadState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelReadState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelReadState sets the old ChannelReadState of the mutation.
func withChannelReadState(node *ChannelReadState) channelreadstateOption {
	return func(m *ChannelReadStateMutation) {
		m.oldValue = func(context.Context) (*ChannelReadState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelReadStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelReadStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelReadState entities.
func (m *ChannelReadStateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelReadStateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelReadStateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelReadState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastReadAt sets the "last_read_at" field.
func (m *ChannelReadStateMutation) SetLastReadAt(t time.Time) {
	m.last_read_at = &t
}

// LastReadAt returns the value of the "last_read_at" field in the mutation.
func (m *ChannelReadStateMutation) LastReadAt() (r time.Time, exists bool) {
	v := m.last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadAt returns the old "last_read_at" field's value of the ChannelReadState entity.
// If the ChannelReadState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelReadStateMutation) OldLastReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadAt: %w", err)
	}
	return oldValue.LastReadAt, nil
}

// ResetLastReadAt resets all changes to the "last_read_at" field.
func (m *ChannelReadStateMutation) ResetLastReadAt() {
	m.last_read_at = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *ChannelReadStateMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelReadStateMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelReadStateMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *ChannelReadStateMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelReadStateMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelReadStateMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChannelReadStateMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelReadStateMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelReadStateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChannelReadStateMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelReadStateMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelReadStateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ChannelReadStateMutation builder.
func (m *ChannelReadStateMutation) Where(ps ...predicate.ChannelReadState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelReadStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelReadStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelReadState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelReadStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelReadStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelReadState).
func (m *ChannelReadStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelReadStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_read_at != nil {
		fields = append(fields, channelreadstate.FieldLastReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelReadStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelreadstate.FieldLastReadAt:
		return m.LastReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelReadStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelreadstate.FieldLastReadAt:
		return m.OldLastReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelReadState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelReadStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelreadstate.FieldLastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelReadState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelReadStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelReadStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelReadStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChannelReadState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelReadStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelReadStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelReadStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChannelReadState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelReadStateMutation) ResetField(name string) error {
	switch name {
	case channelreadstate.FieldLastReadAt:
		m.ResetLastReadAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelReadState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelReadStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel != nil {
		edges = append(edges, channelreadstate.EdgeChannel)
	}
	if m.user != nil {
		edges = append(edges, channelreadstate.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelReadStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelreadstate.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case channelreadstate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelReadStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelReadStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelReadStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel {
		edges = append(edges, channelreadstate.EdgeChannel)
	}
	if m.cleareduser {
		edges = append(edges, channelreadstate.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelReadStateMutation) EdgeCleared(name string) bool {
	switch name {
	case channelreadstate.EdgeChannel:
		return m.clearedchannel
	case channelreadstate.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelReadStateMutation) ClearEdge(name string) error {
	switch name {
	case channelreadstate.EdgeChannel:
		m.ClearChannel()
		return nil
	case channelreadstate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelReadState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelReadStateMutation) ResetEdge(name string) error {
	switch name {
	case channelreadstate.EdgeChannel:
		m.ResetChannel()
		return nil
	case channelreadstate.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelReadState edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	body                       *string
	created_at                 *time.Time
	edited_at                  *time.Time
	deleted_at                 *time.Time
	deleted_by                 *uuid.UUID
	clearedFields              map[string]struct{}
	channel                    *uuid.UUID
	clearedchannel             bool
	user                       *uuid.UUID
	cleareduser                bool
	parent                     *uuid.UUID
	clearedparent              bool
	replies                    map[uuid.UUID]struct{}
	removedreplies             map[uuid.UUID]struct{}
	clearedreplies             bool
	reactions                  map[uuid.UUID]struct{}
	removedreactions           map[uuid.UUID]struct{}
	clearedreactions           bool
	bookmarks                  map[uuid.UUID]struct{}
	removedbookmarks           map[uuid.UUID]struct{}
	clearedbookmarks           bool
	user_mentions              map[uuid.UUID]struct{}
	removeduser_mentions       map[uuid.UUID]struct{}
	cleareduser_mentions       bool
	group_mentions             map[uuid.UUID]struct{}
	removedgroup_mentions      map[uuid.UUID]struct{}
	clearedgroup_mentions      bool
	links                      map[uuid.UUID]struct{}
	removedlinks               map[uuid.UUID]struct{}
	clearedlinks               bool
	attachments                map[uuid.UUID]struct{}
	removedattachments         map[uuid.UUID]struct{}
	clearedattachments         bool
	thread_metadata            map[uuid.UUID]struct{}
	removedthread_metadata     map[uuid.UUID]struct{}
	clearedthread_metadata     bool
	user_thread_follows        map[uuid.UUID]struct{}
	removeduser_thread_follows map[uuid.UUID]struct{}
	cleareduser_thread_follows bool
	thread_read_states         map[uuid.UUID]struct{}
	removedthread_read_states  map[uuid.UUID]struct{}
	clearedthread_read_states  bool
	done                       bool
	oldValue                   func(context.Context) (*Message, error)
	predicates                 []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBody sets the "body" field.
func (m *MessageMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *MessageMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *MessageMutation) ResetBody() {
	m.body = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEditedAt sets the "edited_at" field.
func (m *MessageMutation) SetEditedAt(t time.Time) {
	m.edited_at = &t
}

// EditedAt returns the value of the "edited_at" field in the mutation.
func (m *MessageMutation) EditedAt() (r time.Time, exists bool) {
	v := m.edited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEditedAt returns the old "edited_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldEditedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditedAt: %w", err)
	}
	return oldValue.EditedAt, nil
}

// ClearEditedAt clears the value of the "edited_at" field.
func (m *MessageMutation) ClearEditedAt() {
	m.edited_at = nil
	m.clearedFields[message.FieldEditedAt] = struct{}{}
}

// EditedAtCleared returns if the "edited_at" field was cleared in this mutation.
func (m *MessageMutation) EditedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldEditedAt]
	return ok
}

// ResetEditedAt resets all changes to the "edited_at" field.
func (m *MessageMutation) ResetEditedAt() {
	m.edited_at = nil
	delete(m.clearedFields, message.FieldEditedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *MessageMutation) SetDeletedBy(u uuid.UUID) {
	m.deleted_by = &u
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *MessageMutation) DeletedBy() (r uuid.UUID, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *MessageMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[message.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *MessageMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *MessageMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, message.FieldDeletedBy)
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *MessageMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *MessageMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *MessageMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *MessageMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *MessageMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MessageMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MessageMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetParentID sets the "parent" edge to the Message entity by id.
func (m *MessageMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Message entity.
func (m *MessageMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Message entity was cleared.
func (m *MessageMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *MessageMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MessageMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the Message entity by ids.
func (m *MessageMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Message entity.
func (m *MessageMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Message entity was cleared.
func (m *MessageMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Message entity by IDs.
func (m *MessageMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Message entity.
func (m *MessageMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *MessageMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *MessageMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddReactionIDs adds the "reactions" edge to the MessageReaction entity by ids.
func (m *MessageMutation) AddReactionIDs(ids ...uuid.UUID) {
	if m.reactions == nil {
		m.reactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reactions[ids[i]] = struct{}{}
	}
}

// ClearReactions clears the "reactions" edge to the MessageReaction entity.
func (m *MessageMutation) ClearReactions() {
	m.clearedreactions = true
}

// ReactionsCleared reports if the "reactions" edge to the MessageReaction entity was cleared.
func (m *MessageMutation) ReactionsCleared() bool {
	return m.clearedreactions
}

// RemoveReactionIDs removes the "reactions" edge to the MessageReaction entity by IDs.
func (m *MessageMutation) RemoveReactionIDs(ids ...uuid.UUID) {
	if m.removedreactions == nil {
		m.removedreactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reactions, ids[i])
		m.removedreactions[ids[i]] = struct{}{}
	}
}

// RemovedReactions returns the removed IDs of the "reactions" edge to the MessageReaction entity.
func (m *MessageMutation) RemovedReactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedreactions {
		ids = append(ids, id)
	}
	return
}

// ReactionsIDs returns the "reactions" edge IDs in the mutation.
func (m *MessageMutation) ReactionsIDs() (ids []uuid.UUID) {
	for id := range m.reactions {
		ids = append(ids, id)
	}
	return
}

// ResetReactions resets all changes to the "reactions" edge.
func (m *MessageMutation) ResetReactions() {
	m.reactions = nil
	m.clearedreactions = false
	m.removedreactions = nil
}

// AddBookmarkIDs adds the "bookmarks" edge to the MessageBookmark entity by ids.
func (m *MessageMutation) AddBookmarkIDs(ids ...uuid.UUID) {
	if m.bookmarks == nil {
		m.bookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bookmarks[ids[i]] = struct{}{}
	}
}

// ClearBookmarks clears the "bookmarks" edge to the MessageBookmark entity.
func (m *MessageMutation) ClearBookmarks() {
	m.clearedbookmarks = true
}

// BookmarksCleared reports if the "bookmarks" edge to the MessageBookmark entity was cleared.
func (m *MessageMutation) BookmarksCleared() bool {
	return m.clearedbookmarks
}

// RemoveBookmarkIDs removes the "bookmarks" edge to the MessageBookmark entity by IDs.
func (m *MessageMutation) RemoveBookmarkIDs(ids ...uuid.UUID) {
	if m.removedbookmarks == nil {
		m.removedbookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bookmarks, ids[i])
		m.removedbookmarks[ids[i]] = struct{}{}
	}
}

// RemovedBookmarks returns the removed IDs of the "bookmarks" edge to the MessageBookmark entity.
func (m *MessageMutation) RemovedBookmarksIDs() (ids []uuid.UUID) {
	for id := range m.removedbookmarks {
		ids = append(ids, id)
	}
	return
}

// BookmarksIDs returns the "bookmarks" edge IDs in the mutation.
func (m *MessageMutation) BookmarksIDs() (ids []uuid.UUID) {
	for id := range m.bookmarks {
		ids = append(ids, id)
	}
	return
}

// ResetBookmarks resets all changes to the "bookmarks" edge.
func (m *MessageMutation) ResetBookmarks() {
	m.bookmarks = nil
	m.clearedbookmarks = false
	m.removedbookmarks = nil
}

// AddUserMentionIDs adds the "user_mentions" edge to the MessageUserMention entity by ids.
func (m *MessageMutation) AddUserMentionIDs(ids ...uuid.UUID) {
	if m.user_mentions == nil {
		m.user_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_mentions[ids[i]] = struct{}{}
	}
}

// ClearUserMentions clears the "user_mentions" edge to the MessageUserMention entity.
func (m *MessageMutation) ClearUserMentions() {
	m.cleareduser_mentions = true
}

// UserMentionsCleared reports if the "user_mentions" edge to the MessageUserMention entity was cleared.
func (m *MessageMutation) UserMentionsCleared() bool {
	return m.cleareduser_mentions
}

// RemoveUserMentionIDs removes the "user_mentions" edge to the MessageUserMention entity by IDs.
func (m *MessageMutation) RemoveUserMentionIDs(ids ...uuid.UUID) {
	if m.removeduser_mentions == nil {
		m.removeduser_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_mentions, ids[i])
		m.removeduser_mentions[ids[i]] = struct{}{}
	}
}

// RemovedUserMentions returns the removed IDs of the "user_mentions" edge to the MessageUserMention entity.
func (m *MessageMutation) RemovedUserMentionsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_mentions {
		ids = append(ids, id)
	}
	return
}

// UserMentionsIDs returns the "user_mentions" edge IDs in the mutation.
func (m *MessageMutation) UserMentionsIDs() (ids []uuid.UUID) {
	for id := range m.user_mentions {
		ids = append(ids, id)
	}
	return
}

// ResetUserMentions resets all changes to the "user_mentions" edge.
func (m *MessageMutation) ResetUserMentions() {
	m.user_mentions = nil
	m.cleareduser_mentions = false
	m.removeduser_mentions = nil
}

// AddGroupMentionIDs adds the "group_mentions" edge to the MessageGroupMention entity by ids.
func (m *MessageMutation) AddGroupMentionIDs(ids ...uuid.UUID) {
	if m.group_mentions == nil {
		m.group_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.group_mentions[ids[i]] = struct{}{}
	}
}

// ClearGroupMentions clears the "group_mentions" edge to the MessageGroupMention entity.
func (m *MessageMutation) ClearGroupMentions() {
	m.clearedgroup_mentions = true
}

// GroupMentionsCleared reports if the "group_mentions" edge to the MessageGroupMention entity was cleared.
func (m *MessageMutation) GroupMentionsCleared() bool {
	return m.clearedgroup_mentions
}

// RemoveGroupMentionIDs removes the "group_mentions" edge to the MessageGroupMention entity by IDs.
func (m *MessageMutation) RemoveGroupMentionIDs(ids ...uuid.UUID) {
	if m.removedgroup_mentions == nil {
		m.removedgroup_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.group_mentions, ids[i])
		m.removedgroup_mentions[ids[i]] = struct{}{}
	}
}

// RemovedGroupMentions returns the removed IDs of the "group_mentions" edge to the MessageGroupMention entity.
func (m *MessageMutation) RemovedGroupMentionsIDs() (ids []uuid.UUID) {
	for id := range m.removedgroup_mentions {
		ids = append(ids, id)
	}
	return
}

// GroupMentionsIDs returns the "group_mentions" edge IDs in the mutation.
func (m *MessageMutation) GroupMentionsIDs() (ids []uuid.UUID) {
	for id := range m.group_mentions {
		ids = append(ids, id)
	}
	return
}

// ResetGroupMentions resets all changes to the "group_mentions" edge.
func (m *MessageMutation) ResetGroupMentions() {
	m.group_mentions = nil
	m.clearedgroup_mentions = false
	m.removedgroup_mentions = nil
}

// AddLinkIDs adds the "links" edge to the MessageLink entity by ids.
func (m *MessageMutation) AddLinkIDs(ids ...uuid.UUID) {
	if m.links == nil {
		m.links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the MessageLink entity.
func (m *MessageMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the MessageLink entity was cleared.
func (m *MessageMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the MessageLink entity by IDs.
func (m *MessageMutation) RemoveLinkIDs(ids ...uuid.UUID) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the MessageLink entity.
func (m *MessageMutation) RemovedLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *MessageMutation) LinksIDs() (ids []uuid.UUID) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *MessageMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *MessageMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *MessageMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *MessageMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *MessageMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *MessageMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *MessageMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *MessageMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddThreadMetadatumIDs adds the "thread_metadata" edge to the ThreadMetadata entity by ids.
func (m *MessageMutation) AddThreadMetadatumIDs(ids ...uuid.UUID) {
	if m.thread_metadata == nil {
		m.thread_metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.thread_metadata[ids[i]] = struct{}{}
	}
}

// ClearThreadMetadata clears the "thread_metadata" edge to the ThreadMetadata entity.
func (m *MessageMutation) ClearThreadMetadata() {
	m.clearedthread_metadata = true
}

// ThreadMetadataCleared reports if the "thread_metadata" edge to the ThreadMetadata entity was cleared.
func (m *MessageMutation) ThreadMetadataCleared() bool {
	return m.clearedthread_metadata
}

// RemoveThreadMetadatumIDs removes the "thread_metadata" edge to the ThreadMetadata entity by IDs.
func (m *MessageMutation) RemoveThreadMetadatumIDs(ids ...uuid.UUID) {
	if m.removedthread_metadata == nil {
		m.removedthread_metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.thread_metadata, ids[i])
		m.removedthread_metadata[ids[i]] = struct{}{}
	}
}

// RemovedThreadMetadata returns the removed IDs of the "thread_metadata" edge to the ThreadMetadata entity.
func (m *MessageMutation) RemovedThreadMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedthread_metadata {
		ids = append(ids, id)
	}
	return
}

// ThreadMetadataIDs returns the "thread_metadata" edge IDs in the mutation.
func (m *MessageMutation) ThreadMetadataIDs() (ids []uuid.UUID) {
	for id := range m.thread_metadata {
		ids = append(ids, id)
	}
	return
}

// ResetThreadMetadata resets all changes to the "thread_metadata" edge.
func (m *MessageMutation) ResetThreadMetadata() {
	m.thread_metadata = nil
	m.clearedthread_metadata = false
	m.removedthread_metadata = nil
}

// AddUserThreadFollowIDs adds the "user_thread_follows" edge to the UserThreadFollow entity by ids.
func (m *MessageMutation) AddUserThreadFollowIDs(ids ...uuid.UUID) {
	if m.user_thread_follows == nil {
		m.user_thread_follows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_thread_follows[ids[i]] = struct{}{}
	}
}

// ClearUserThreadFollows clears the "user_thread_follows" edge to the UserThreadFollow entity.
func (m *MessageMutation) ClearUserThreadFollows() {
	m.cleareduser_thread_follows = true
}

// UserThreadFollowsCleared reports if the "user_thread_follows" edge to the UserThreadFollow entity was cleared.
func (m *MessageMutation) UserThreadFollowsCleared() bool {
	return m.cleareduser_thread_follows
}

// RemoveUserThreadFollowIDs removes the "user_thread_follows" edge to the UserThreadFollow entity by IDs.
func (m *MessageMutation) RemoveUserThreadFollowIDs(ids ...uuid.UUID) {
	if m.removeduser_thread_follows == nil {
		m.removeduser_thread_follows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_thread_follows, ids[i])
		m.removeduser_thread_follows[ids[i]] = struct{}{}
	}
}

// RemovedUserThreadFollows returns the removed IDs of the "user_thread_follows" edge to the UserThreadFollow entity.
func (m *MessageMutation) RemovedUserThreadFollowsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_thread_follows {
		ids = append(ids, id)
	}
	return
}

// UserThreadFollowsIDs returns the "user_thread_follows" edge IDs in the mutation.
func (m *MessageMutation) UserThreadFollowsIDs() (ids []uuid.UUID) {
	for id := range m.user_thread_follows {
		ids = append(ids, id)
	}
	return
}

// ResetUserThreadFollows resets all changes to the "user_thread_follows" edge.
func (m *MessageMutation) ResetUserThreadFollows() {
	m.user_thread_follows = nil
	m.cleareduser_thread_follows = false
	m.removeduser_thread_follows = nil
}

// AddThreadReadStateIDs adds the "thread_read_states" edge to the ThreadReadState entity by ids.
func (m *MessageMutation) AddThreadReadStateIDs(ids ...uuid.UUID) {
	if m.thread_read_states == nil {
		m.thread_read_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.thread_read_states[ids[i]] = struct{}{}
	}
}

// ClearThreadReadStates clears the "thread_read_states" edge to the ThreadReadState entity.
func (m *MessageMutation) ClearThreadReadStates() {
	m.clearedthread_read_states = true
}

// ThreadReadStatesCleared reports if the "thread_read_states" edge to the ThreadReadState entity was cleared.
func (m *MessageMutation) ThreadReadStatesCleared() bool {
	return m.clearedthread_read_states
}

// RemoveThreadReadStateIDs removes the "thread_read_states" edge to the ThreadReadState entity by IDs.
func (m *MessageMutation) RemoveThreadReadStateIDs(ids ...uuid.UUID) {
	if m.removedthread_read_states == nil {
		m.removedthread_read_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.thread_read_states, ids[i])
		m.removedthread_read_states[ids[i]] = struct{}{}
	}
}

// RemovedThreadReadStates returns the removed IDs of the "thread_read_states" edge to the ThreadReadState entity.
func (m *MessageMutation) RemovedThreadReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.removedthread_read_states {
		ids = append(ids, id)
	}
	return
}

// ThreadReadStatesIDs returns the "thread_read_states" edge IDs in the mutation.
func (m *MessageMutation) ThreadReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.thread_read_states {
		ids = append(ids, id)
	}
	return
}

// ResetThreadReadStates resets all changes to the "thread_read_states" edge.
func (m *MessageMutation) ResetThreadReadStates() {
	m.thread_read_states = nil
	m.clearedthread_read_states = false
	m.removedthread_read_states = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.body != nil {
		fields = append(fields, message.FieldBody)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.edited_at != nil {
		fields = append(fields, message.FieldEditedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, message.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldBody:
		return m.Body()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldEditedAt:
		return m.EditedAt()
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldBody:
		return m.OldBody(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldEditedAt:
		return m.OldEditedAt(ctx)
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldEditedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditedAt(v)
		return nil
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldDeletedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldEditedAt) {
		fields = append(fields, message.FieldEditedAt)
	}
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.FieldCleared(message.FieldDeletedBy) {
		fields = append(fields, message.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldEditedAt:
		m.ClearEditedAt()
		return nil
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case message.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldBody:
		m.ResetBody()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldEditedAt:
		m.ResetEditedAt()
		return nil
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.channel != nil {
		edges = append(edges, message.EdgeChannel)
	}
	if m.user != nil {
		edges = append(edges, message.EdgeUser)
	}
	if m.parent != nil {
		edges = append(edges, message.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, message.EdgeReplies)
	}
	if m.reactions != nil {
		edges = append(edges, message.EdgeReactions)
	}
	if m.bookmarks != nil {
		edges = append(edges, message.EdgeBookmarks)
	}
	if m.user_mentions != nil {
		edges = append(edges, message.EdgeUserMentions)
	}
	if m.group_mentions != nil {
		edges = append(edges, message.EdgeGroupMentions)
	}
	if m.links != nil {
		edges = append(edges, message.EdgeLinks)
	}
	if m.attachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.thread_metadata != nil {
		edges = append(edges, message.EdgeThreadMetadata)
	}
	if m.user_thread_follows != nil {
		edges = append(edges, message.EdgeUserThreadFollows)
	}
	if m.thread_read_states != nil {
		edges = append(edges, message.EdgeThreadReadStates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.reactions))
		for id := range m.reactions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.bookmarks))
		for id := range m.bookmarks {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeUserMentions:
		ids := make([]ent.Value, 0, len(m.user_mentions))
		for id := range m.user_mentions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeGroupMentions:
		ids := make([]ent.Value, 0, len(m.group_mentions))
		for id := range m.group_mentions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeThreadMetadata:
		ids := make([]ent.Value, 0, len(m.thread_metadata))
		for id := range m.thread_metadata {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeUserThreadFollows:
		ids := make([]ent.Value, 0, len(m.user_thread_follows))
		for id := range m.user_thread_follows {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeThreadReadStates:
		ids := make([]ent.Value, 0, len(m.thread_read_states))
		for id := range m.thread_read_states {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedreplies != nil {
		edges = append(edges, message.EdgeReplies)
	}
	if m.removedreactions != nil {
		edges = append(edges, message.EdgeReactions)
	}
	if m.removedbookmarks != nil {
		edges = append(edges, message.EdgeBookmarks)
	}
	if m.removeduser_mentions != nil {
		edges = append(edges, message.EdgeUserMentions)
	}
	if m.removedgroup_mentions != nil {
		edges = append(edges, message.EdgeGroupMentions)
	}
	if m.removedlinks != nil {
		edges = append(edges, message.EdgeLinks)
	}
	if m.removedattachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.removedthread_metadata != nil {
		edges = append(edges, message.EdgeThreadMetadata)
	}
	if m.removeduser_thread_follows != nil {
		edges = append(edges, message.EdgeUserThreadFollows)
	}
	if m.removedthread_read_states != nil {
		edges = append(edges, message.EdgeThreadReadStates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.removedreactions))
		for id := range m.removedreactions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.removedbookmarks))
		for id := range m.removedbookmarks {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeUserMentions:
		ids := make([]ent.Value, 0, len(m.removeduser_mentions))
		for id := range m.removeduser_mentions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeGroupMentions:
		ids := make([]ent.Value, 0, len(m.removedgroup_mentions))
		for id := range m.removedgroup_mentions {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeThreadMetadata:
		ids := make([]ent.Value, 0, len(m.removedthread_metadata))
		for id := range m.removedthread_metadata {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeUserThreadFollows:
		ids := make([]ent.Value, 0, len(m.removeduser_thread_follows))
		for id := range m.removeduser_thread_follows {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeThreadReadStates:
		ids := make([]ent.Value, 0, len(m.removedthread_read_states))
		for id := range m.removedthread_read_states {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedchannel {
		edges = append(edges, message.EdgeChannel)
	}
	if m.cleareduser {
		edges = append(edges, message.EdgeUser)
	}
	if m.clearedparent {
		edges = append(edges, message.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, message.EdgeReplies)
	}
	if m.clearedreactions {
		edges = append(edges, message.EdgeReactions)
	}
	if m.clearedbookmarks {
		edges = append(edges, message.EdgeBookmarks)
	}
	if m.cleareduser_mentions {
		edges = append(edges, message.EdgeUserMentions)
	}
	if m.clearedgroup_mentions {
		edges = append(edges, message.EdgeGroupMentions)
	}
	if m.clearedlinks {
		edges = append(edges, message.EdgeLinks)
	}
	if m.clearedattachments {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.clearedthread_metadata {
		edges = append(edges, message.EdgeThreadMetadata)
	}
	if m.cleareduser_thread_follows {
		edges = append(edges, message.EdgeUserThreadFollows)
	}
	if m.clearedthread_read_states {
		edges = append(edges, message.EdgeThreadReadStates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeChannel:
		return m.clearedchannel
	case message.EdgeUser:
		return m.cleareduser
	case message.EdgeParent:
		return m.clearedparent
	case message.EdgeReplies:
		return m.clearedreplies
	case message.EdgeReactions:
		return m.clearedreactions
	case message.EdgeBookmarks:
		return m.clearedbookmarks
	case message.EdgeUserMentions:
		return m.cleareduser_mentions
	case message.EdgeGroupMentions:
		return m.clearedgroup_mentions
	case message.EdgeLinks:
		return m.clearedlinks
	case message.EdgeAttachments:
		return m.clearedattachments
	case message.EdgeThreadMetadata:
		return m.clearedthread_metadata
	case message.EdgeUserThreadFollows:
		return m.cleareduser_thread_follows
	case message.EdgeThreadReadStates:
		return m.clearedthread_read_states
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeChannel:
		m.ClearChannel()
		return nil
	case message.EdgeUser:
		m.ClearUser()
		return nil
	case message.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeChannel:
		m.ResetChannel()
		return nil
	case message.EdgeUser:
		m.ResetUser()
		return nil
	case message.EdgeParent:
		m.ResetParent()
		return nil
	case message.EdgeReplies:
		m.ResetReplies()
		return nil
	case message.EdgeReactions:
		m.ResetReactions()
		return nil
	case message.EdgeBookmarks:
		m.ResetBookmarks()
		return nil
	case message.EdgeUserMentions:
		m.ResetUserMentions()
		return nil
	case message.EdgeGroupMentions:
		m.ResetGroupMentions()
		return nil
	case message.EdgeLinks:
		m.ResetLinks()
		return nil
	case message.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case message.EdgeThreadMetadata:
		m.ResetThreadMetadata()
		return nil
	case message.EdgeUserThreadFollows:
		m.ResetUserThreadFollows()
		return nil
	case message.EdgeThreadReadStates:
		m.ResetThreadReadStates()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// MessageBookmarkMutation represents an operation that mutates the MessageBookmark nodes in the graph.
type MessageBookmarkMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	message        *uuid.UUID
	clearedmessage bool
	done           bool
	oldValue       func(context.Context) (*MessageBookmark, error)
	predicates     []predicate.MessageBookmark
}

var _ ent.Mutation = (*MessageBookmarkMutation)(nil)

// messagebookmarkOption allows management of the mutation configuration using functional options.
type messagebookmarkOption func(*MessageBookmarkMutation)

// newMessageBookmarkMutation creates new mutation for the MessageBookmark entity.
func newMessageBookmarkMutation(c config, op Op, opts ...messagebookmarkOption) *MessageBookmarkMutation {
	m := &MessageBookmarkMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageBookmark,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageBookmarkID sets the ID field of the mutation.
func withMessageBookmarkID(id uuid.UUID) messagebookmarkOption {
	return func(m *MessageBookmarkMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageBookmark
		)
		m.oldValue = func(ctx context.Context) (*MessageBookmark, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageBookmark.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageBookmark sets the old MessageBookmark of the mutation.
func withMessageBookmark(node *MessageBookmark) messagebookmarkOption {
	return func(m *MessageBookmarkMutation) {
		m.oldValue = func(context.Context) (*MessageBookmark, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageBookmarkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageBookmarkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessageBookmark entities.
func (m *MessageBookmarkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageBookmarkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageBookmarkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageBookmark.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageBookmarkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageBookmarkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageBookmark entity.
// If the MessageBookmark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageBookmarkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageBookmarkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MessageBookmarkMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageBookmarkMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageBookmarkMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MessageBookmarkMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageBookmarkMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageBookmarkMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessageBookmarkMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessageBookmarkMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessageBookmarkMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessageBookmarkMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessageBookmarkMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessageBookmarkMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// Where appends a list predicates to the MessageBookmarkMutation builder.
func (m *MessageBookmarkMutation) Where(ps ...predicate.MessageBookmark) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageBookmarkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageBookmarkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageBookmark, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageBookmarkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageBookmarkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageBookmark).
func (m *MessageBookmarkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageBookmarkMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, messagebookmark.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageBookmarkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagebookmark.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageBookmarkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagebookmark.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageBookmark field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageBookmarkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagebookmark.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageBookmark field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageBookmarkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageBookmarkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageBookmarkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageBookmark numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageBookmarkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageBookmarkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageBookmarkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessageBookmark nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageBookmarkMutation) ResetField(name string) error {
	switch name {
	case messagebookmark.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageBookmark field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageBookmarkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, messagebookmark.EdgeUser)
	}
	if m.message != nil {
		edges = append(edges, messagebookmark.EdgeMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageBookmarkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagebookmark.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case messagebookmark.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageBookmarkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageBookmarkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageBookmarkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, messagebookmark.EdgeUser)
	}
	if m.clearedmessage {
		edges = append(edges, messagebookmark.EdgeMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageBookmarkMutation) EdgeCleared(name string) bool {
	switch name {
	case messagebookmark.EdgeUser:
		return m.cleareduser
	case messagebookmark.EdgeMessage:
		return m.clearedmessage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageBookmarkMutation) ClearEdge(name string) error {
	switch name {
	case messagebookmark.EdgeUser:
		m.ClearUser()
		return nil
	case messagebookmark.EdgeMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown MessageBookmark unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageBookmarkMutation) ResetEdge(name string) error {
	switch name {
	case messagebookmark.EdgeUser:
		m.ResetUser()
		return nil
	case messagebookmark.EdgeMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown MessageBookmark edge %s", name)
}

// MessageGroupMentionMutation represents an operation that mutates the MessageGroupMention nodes in the graph.
type MessageGroupMentionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	group          *uuid.UUID
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*MessageGroupMention, error)
	predicates     []predicate.MessageGroupMention
}

var _ ent.Mutation = (*MessageGroupMentionMutation)(nil)

// messagegroupmentionOption allows management of the mutation configuration using functional options.
type messagegroupmentionOption func(*MessageGroupMentionMutation)

// newMessageGroupMentionMutation creates new mutation for the MessageGroupMention entity.
func newMessageGroupMentionMutation(c config, op Op, opts ...messagegroupmentionOption) *MessageGroupMentionMutation {
	m := &MessageGroupMentionMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageGroupMention,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageGroupMentionID sets the ID field of the mutation.
func withMessageGroupMentionID(id uuid.UUID) messagegroupmentionOption {
	return func(m *MessageGroupMentionMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageGroupMention
		)
		m.oldValue = func(ctx context.Context) (*MessageGroupMention, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageGroupMention.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageGroupMention sets the old MessageGroupMention of the mutation.
func withMessageGroupMention(node *MessageGroupMention) messagegroupmentionOption {
	return func(m *MessageGroupMentionMutation) {
		m.oldValue = func(context.Context) (*MessageGroupMention, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageGroupMentionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageGroupMentionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessageGroupMention entities.
func (m *MessageGroupMentionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageGroupMentionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageGroupMentionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageGroupMention.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageGroupMentionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageGroupMentionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageGroupMention entity.
// If the MessageGroupMention object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageGroupMentionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageGroupMentionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessageGroupMentionMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessageGroupMentionMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessageGroupMentionMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessageGroupMentionMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessageGroupMentionMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessageGroupMentionMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetGroupID sets the "group" edge to the UserGroup entity by id.
func (m *MessageGroupMentionMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the UserGroup entity.
func (m *MessageGroupMentionMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the UserGroup entity was cleared.
func (m *MessageGroupMentionMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *MessageGroupMentionMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *MessageGroupMentionMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *MessageGroupMentionMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the MessageGroupMentionMutation builder.
func (m *MessageGroupMentionMutation) Where(ps ...predicate.MessageGroupMention) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageGroupMentionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageGroupMentionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageGroupMention, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageGroupMentionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageGroupMentionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageGroupMention).
func (m *MessageGroupMentionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageGroupMentionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, messagegroupmention.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageGroupMentionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagegroupmention.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageGroupMentionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagegroupmention.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageGroupMention field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageGroupMentionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagegroupmention.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageGroupMention field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageGroupMentionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageGroupMentionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageGroupMentionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageGroupMention numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageGroupMentionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageGroupMentionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageGroupMentionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessageGroupMention nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageGroupMentionMutation) ResetField(name string) error {
	switch name {
	case messagegroupmention.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageGroupMention field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageGroupMentionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.message != nil {
		edges = append(edges, messagegroupmention.EdgeMessage)
	}
	if m.group != nil {
		edges = append(edges, messagegroupmention.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageGroupMentionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagegroupmention.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case messagegroupmention.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageGroupMentionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageGroupMentionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageGroupMentionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessage {
		edges = append(edges, messagegroupmention.EdgeMessage)
	}
	if m.clearedgroup {
		edges = append(edges, messagegroupmention.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageGroupMentionMutation) EdgeCleared(name string) bool {
	switch name {
	case messagegroupmention.EdgeMessage:
		return m.clearedmessage
	case messagegroupmention.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageGroupMentionMutation) ClearEdge(name string) error {
	switch name {
	case messagegroupmention.EdgeMessage:
		m.ClearMessage()
		return nil
	case messagegroupmention.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown MessageGroupMention unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageGroupMentionMutation) ResetEdge(name string) error {
	switch name {
	case messagegroupmention.EdgeMessage:
		m.ResetMessage()
		return nil
	case messagegroupmention.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown MessageGroupMention edge %s", name)
}

// MessageLinkMutation represents an operation that mutates the MessageLink nodes in the graph.
type MessageLinkMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	url            *string
	title          *string
	description    *string
	image_url      *string
	site_name      *string
	card_type      *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	done           bool
	oldValue       func(context.Context) (*MessageLink, error)
	predicates     []predicate.MessageLink
}

var _ ent.Mutation = (*MessageLinkMutation)(nil)

// messagelinkOption allows management of the mutation configuration using functional options.
type messagelinkOption func(*MessageLinkMutation)

// newMessageLinkMutation creates new mutation for the MessageLink entity.
func newMessageLinkMutation(c config, op Op, opts ...messagelinkOption) *MessageLinkMutation {
	m := &MessageLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageLinkID sets the ID field of the mutation.
func withMessageLinkID(id uuid.UUID) messagelinkOption {
	return func(m *MessageLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageLink
		)
		m.oldValue = func(ctx context.Context) (*MessageLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageLink sets the old MessageLink of the mutation.
func withMessageLink(node *MessageLink) messagelinkOption {
	return func(m *MessageLinkMutation) {
		m.oldValue = func(context.Context) (*MessageLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessageLink entities.
func (m *MessageLinkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageLinkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageLinkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *MessageLinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MessageLinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *MessageLinkMutation) ResetURL() {
	m.url = nil
}

// SetTitle sets the "title" field.
func (m *MessageLinkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MessageLinkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *MessageLinkMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[messagelink.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *MessageLinkMutation) TitleCleared() bool {
	_, ok := m.clearedFields[messagelink.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *MessageLinkMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, messagelink.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *MessageLinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MessageLinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MessageLinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[messagelink.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MessageLinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[messagelink.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MessageLinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, messagelink.FieldDescription)
}

// SetImageURL sets the "image_url" field.
func (m *MessageLinkMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *MessageLinkMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *MessageLinkMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[messagelink.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *MessageLinkMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[messagelink.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *MessageLinkMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, messagelink.FieldImageURL)
}

// SetSiteName sets the "site_name" field.
func (m *MessageLinkMutation) SetSiteName(s string) {
	m.site_name = &s
}

// SiteName returns the value of the "site_name" field in the mutation.
func (m *MessageLinkMutation) SiteName() (r string, exists bool) {
	v := m.site_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteName returns the old "site_name" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldSiteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteName: %w", err)
	}
	return oldValue.SiteName, nil
}

// ClearSiteName clears the value of the "site_name" field.
func (m *MessageLinkMutation) ClearSiteName() {
	m.site_name = nil
	m.clearedFields[messagelink.FieldSiteName] = struct{}{}
}

// SiteNameCleared returns if the "site_name" field was cleared in this mutation.
func (m *MessageLinkMutation) SiteNameCleared() bool {
	_, ok := m.clearedFields[messagelink.FieldSiteName]
	return ok
}

// ResetSiteName resets all changes to the "site_name" field.
func (m *MessageLinkMutation) ResetSiteName() {
	m.site_name = nil
	delete(m.clearedFields, messagelink.FieldSiteName)
}

// SetCardType sets the "card_type" field.
func (m *MessageLinkMutation) SetCardType(s string) {
	m.card_type = &s
}

// CardType returns the value of the "card_type" field in the mutation.
func (m *MessageLinkMutation) CardType() (r string, exists bool) {
	v := m.card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCardType returns the old "card_type" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldCardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardType: %w", err)
	}
	return oldValue.CardType, nil
}

// ClearCardType clears the value of the "card_type" field.
func (m *MessageLinkMutation) ClearCardType() {
	m.card_type = nil
	m.clearedFields[messagelink.FieldCardType] = struct{}{}
}

// CardTypeCleared returns if the "card_type" field was cleared in this mutation.
func (m *MessageLinkMutation) CardTypeCleared() bool {
	_, ok := m.clearedFields[messagelink.FieldCardType]
	return ok
}

// ResetCardType resets all changes to the "card_type" field.
func (m *MessageLinkMutation) ResetCardType() {
	m.card_type = nil
	delete(m.clearedFields, messagelink.FieldCardType)
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageLink entity.
// If the MessageLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessageLinkMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessageLinkMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessageLinkMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessageLinkMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessageLinkMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessageLinkMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// Where appends a list predicates to the MessageLinkMutation builder.
func (m *MessageLinkMutation) Where(ps ...predicate.MessageLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageLink).
func (m *MessageLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.url != nil {
		fields = append(fields, messagelink.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, messagelink.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, messagelink.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, messagelink.FieldImageURL)
	}
	if m.site_name != nil {
		fields = append(fields, messagelink.FieldSiteName)
	}
	if m.card_type != nil {
		fields = append(fields, messagelink.FieldCardType)
	}
	if m.created_at != nil {
		fields = append(fields, messagelink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagelink.FieldURL:
		return m.URL()
	case messagelink.FieldTitle:
		return m.Title()
	case messagelink.FieldDescription:
		return m.Description()
	case messagelink.FieldImageURL:
		return m.ImageURL()
	case messagelink.FieldSiteName:
		return m.SiteName()
	case messagelink.FieldCardType:
		return m.CardType()
	case messagelink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagelink.FieldURL:
		return m.OldURL(ctx)
	case messagelink.FieldTitle:
		return m.OldTitle(ctx)
	case messagelink.FieldDescription:
		return m.OldDescription(ctx)
	case messagelink.FieldImageURL:
		return m.OldImageURL(ctx)
	case messagelink.FieldSiteName:
		return m.OldSiteName(ctx)
	case messagelink.FieldCardType:
		return m.OldCardType(ctx)
	case messagelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagelink.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case messagelink.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case messagelink.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case messagelink.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case messagelink.FieldSiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteName(v)
		return nil
	case messagelink.FieldCardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardType(v)
		return nil
	case messagelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messagelink.FieldTitle) {
		fields = append(fields, messagelink.FieldTitle)
	}
	if m.FieldCleared(messagelink.FieldDescription) {
		fields = append(fields, messagelink.FieldDescription)
	}
	if m.FieldCleared(messagelink.FieldImageURL) {
		fields = append(fields, messagelink.FieldImageURL)
	}
	if m.FieldCleared(messagelink.FieldSiteName) {
		fields = append(fields, messagelink.FieldSiteName)
	}
	if m.FieldCleared(messagelink.FieldCardType) {
		fields = append(fields, messagelink.FieldCardType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageLinkMutation) ClearField(name string) error {
	switch name {
	case messagelink.FieldTitle:
		m.ClearTitle()
		return nil
	case messagelink.FieldDescription:
		m.ClearDescription()
		return nil
	case messagelink.FieldImageURL:
		m.ClearImageURL()
		return nil
	case messagelink.FieldSiteName:
		m.ClearSiteName()
		return nil
	case messagelink.FieldCardType:
		m.ClearCardType()
		return nil
	}
	return fmt.Errorf("unknown MessageLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageLinkMutation) ResetField(name string) error {
	switch name {
	case messagelink.FieldURL:
		m.ResetURL()
		return nil
	case messagelink.FieldTitle:
		m.ResetTitle()
		return nil
	case messagelink.FieldDescription:
		m.ResetDescription()
		return nil
	case messagelink.FieldImageURL:
		m.ResetImageURL()
		return nil
	case messagelink.FieldSiteName:
		m.ResetSiteName()
		return nil
	case messagelink.FieldCardType:
		m.ResetCardType()
		return nil
	case messagelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.message != nil {
		edges = append(edges, messagelink.EdgeMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagelink.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmessage {
		edges = append(edges, messagelink.EdgeMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case messagelink.EdgeMessage:
		return m.clearedmessage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageLinkMutation) ClearEdge(name string) error {
	switch name {
	case messagelink.EdgeMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown MessageLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageLinkMutation) ResetEdge(name string) error {
	switch name {
	case messagelink.EdgeMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown MessageLink edge %s", name)
}

// MessagePinMutation represents an operation that mutates the MessagePin nodes in the graph.
type MessagePinMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	clearedFields    map[string]struct{}
	channel          *uuid.UUID
	clearedchannel   bool
	message          *uuid.UUID
	clearedmessage   bool
	pinned_by        *uuid.UUID
	clearedpinned_by bool
	done             bool
	oldValue         func(context.Context) (*MessagePin, error)
	predicates       []predicate.MessagePin
}

var _ ent.Mutation = (*MessagePinMutation)(nil)

// messagepinOption allows management of the mutation configuration using functional options.
type messagepinOption func(*MessagePinMutation)

// newMessagePinMutation creates new mutation for the MessagePin entity.
func newMessagePinMutation(c config, op Op, opts ...messagepinOption) *MessagePinMutation {
	m := &MessagePinMutation{
		config:        c,
		op:            op,
		typ:           TypeMessagePin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagePinID sets the ID field of the mutation.
func withMessagePinID(id uuid.UUID) messagepinOption {
	return func(m *MessagePinMutation) {
		var (
			err   error
			once  sync.Once
			value *MessagePin
		)
		m.oldValue = func(ctx context.Context) (*MessagePin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessagePin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessagePin sets the old MessagePin of the mutation.
func withMessagePin(node *MessagePin) messagepinOption {
	return func(m *MessagePinMutation) {
		m.oldValue = func(context.Context) (*MessagePin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagePinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagePinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessagePin entities.
func (m *MessagePinMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagePinMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagePinMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessagePin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagePinMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagePinMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessagePin entity.
// If the MessagePin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagePinMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagePinMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *MessagePinMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *MessagePinMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *MessagePinMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *MessagePinMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *MessagePinMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *MessagePinMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessagePinMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessagePinMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessagePinMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessagePinMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessagePinMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessagePinMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetPinnedByID sets the "pinned_by" edge to the User entity by id.
func (m *MessagePinMutation) SetPinnedByID(id uuid.UUID) {
	m.pinned_by = &id
}

// ClearPinnedBy clears the "pinned_by" edge to the User entity.
func (m *MessagePinMutation) ClearPinnedBy() {
	m.clearedpinned_by = true
}

// PinnedByCleared reports if the "pinned_by" edge to the User entity was cleared.
func (m *MessagePinMutation) PinnedByCleared() bool {
	return m.clearedpinned_by
}

// PinnedByID returns the "pinned_by" edge ID in the mutation.
func (m *MessagePinMutation) PinnedByID() (id uuid.UUID, exists bool) {
	if m.pinned_by != nil {
		return *m.pinned_by, true
	}
	return
}

// PinnedByIDs returns the "pinned_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PinnedByID instead. It exists only for internal usage by the builders.
func (m *MessagePinMutation) PinnedByIDs() (ids []uuid.UUID) {
	if id := m.pinned_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPinnedBy resets all changes to the "pinned_by" edge.
func (m *MessagePinMutation) ResetPinnedBy() {
	m.pinned_by = nil
	m.clearedpinned_by = false
}

// Where appends a list predicates to the MessagePinMutation builder.
func (m *MessagePinMutation) Where(ps ...predicate.MessagePin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagePinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagePinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessagePin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagePinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagePinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessagePin).
func (m *MessagePinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagePinMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, messagepin.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagePinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagepin.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagePinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagepin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessagePin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagePinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagepin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessagePin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagePinMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagePinMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagePinMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessagePin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagePinMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagePinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagePinMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessagePin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagePinMutation) ResetField(name string) error {
	switch name {
	case messagepin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessagePin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagePinMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.channel != nil {
		edges = append(edges, messagepin.EdgeChannel)
	}
	if m.message != nil {
		edges = append(edges, messagepin.EdgeMessage)
	}
	if m.pinned_by != nil {
		edges = append(edges, messagepin.EdgePinnedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagePinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagepin.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case messagepin.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case messagepin.EdgePinnedBy:
		if id := m.pinned_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagePinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagePinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagePinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchannel {
		edges = append(edges, messagepin.EdgeChannel)
	}
	if m.clearedmessage {
		edges = append(edges, messagepin.EdgeMessage)
	}
	if m.clearedpinned_by {
		edges = append(edges, messagepin.EdgePinnedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagePinMutation) EdgeCleared(name string) bool {
	switch name {
	case messagepin.EdgeChannel:
		return m.clearedchannel
	case messagepin.EdgeMessage:
		return m.clearedmessage
	case messagepin.EdgePinnedBy:
		return m.clearedpinned_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagePinMutation) ClearEdge(name string) error {
	switch name {
	case messagepin.EdgeChannel:
		m.ClearChannel()
		return nil
	case messagepin.EdgeMessage:
		m.ClearMessage()
		return nil
	case messagepin.EdgePinnedBy:
		m.ClearPinnedBy()
		return nil
	}
	return fmt.Errorf("unknown MessagePin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagePinMutation) ResetEdge(name string) error {
	switch name {
	case messagepin.EdgeChannel:
		m.ResetChannel()
		return nil
	case messagepin.EdgeMessage:
		m.ResetMessage()
		return nil
	case messagepin.EdgePinnedBy:
		m.ResetPinnedBy()
		return nil
	}
	return fmt.Errorf("unknown MessagePin edge %s", name)
}

// MessageReactionMutation represents an operation that mutates the MessageReaction nodes in the graph.
type MessageReactionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	emoji          *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*MessageReaction, error)
	predicates     []predicate.MessageReaction
}

var _ ent.Mutation = (*MessageReactionMutation)(nil)

// messagereactionOption allows management of the mutation configuration using functional options.
type messagereactionOption func(*MessageReactionMutation)

// newMessageReactionMutation creates new mutation for the MessageReaction entity.
func newMessageReactionMutation(c config, op Op, opts ...messagereactionOption) *MessageReactionMutation {
	m := &MessageReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageReactionID sets the ID field of the mutation.
func withMessageReactionID(id uuid.UUID) messagereactionOption {
	return func(m *MessageReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageReaction
		)
		m.oldValue = func(ctx context.Context) (*MessageReaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageReaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageReaction sets the old MessageReaction of the mutation.
func withMessageReaction(node *MessageReaction) messagereactionOption {
	return func(m *MessageReactionMutation) {
		m.oldValue = func(context.Context) (*MessageReaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessageReaction entities.
func (m *MessageReactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageReactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageReactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageReaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmoji sets the "emoji" field.
func (m *MessageReactionMutation) SetEmoji(s string) {
	m.emoji = &s
}

// Emoji returns the value of the "emoji" field in the mutation.
func (m *MessageReactionMutation) Emoji() (r string, exists bool) {
	v := m.emoji
	if v == nil {
		return
	}
	return *v, true
}

// OldEmoji returns the old "emoji" field's value of the MessageReaction entity.
// If the MessageReaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageReactionMutation) OldEmoji(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmoji is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmoji requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmoji: %w", err)
	}
	return oldValue.Emoji, nil
}

// ResetEmoji resets all changes to the "emoji" field.
func (m *MessageReactionMutation) ResetEmoji() {
	m.emoji = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageReactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageReactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageReaction entity.
// If the MessageReaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageReactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageReactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessageReactionMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessageReactionMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessageReactionMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessageReactionMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessageReactionMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessageReactionMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MessageReactionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageReactionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageReactionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MessageReactionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageReactionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageReactionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MessageReactionMutation builder.
func (m *MessageReactionMutation) Where(ps ...predicate.MessageReaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageReactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageReactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageReaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageReactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageReactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageReaction).
func (m *MessageReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageReactionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.emoji != nil {
		fields = append(fields, messagereaction.FieldEmoji)
	}
	if m.created_at != nil {
		fields = append(fields, messagereaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageReactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagereaction.FieldEmoji:
		return m.Emoji()
	case messagereaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagereaction.FieldEmoji:
		return m.OldEmoji(ctx)
	case messagereaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageReaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagereaction.FieldEmoji:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmoji(v)
		return nil
	case messagereaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageReaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageReactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageReactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageReactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageReaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessageReaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageReactionMutation) ResetField(name string) error {
	switch name {
	case messagereaction.FieldEmoji:
		m.ResetEmoji()
		return nil
	case messagereaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageReaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.message != nil {
		edges = append(edges, messagereaction.EdgeMessage)
	}
	if m.user != nil {
		edges = append(edges, messagereaction.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageReactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagereaction.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case messagereaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessage {
		edges = append(edges, messagereaction.EdgeMessage)
	}
	if m.cleareduser {
		edges = append(edges, messagereaction.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageReactionMutation) EdgeCleared(name string) bool {
	switch name {
	case messagereaction.EdgeMessage:
		return m.clearedmessage
	case messagereaction.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageReactionMutation) ClearEdge(name string) error {
	switch name {
	case messagereaction.EdgeMessage:
		m.ClearMessage()
		return nil
	case messagereaction.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MessageReaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageReactionMutation) ResetEdge(name string) error {
	switch name {
	case messagereaction.EdgeMessage:
		m.ResetMessage()
		return nil
	case messagereaction.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MessageReaction edge %s", name)
}

// MessageUserMentionMutation represents an operation that mutates the MessageUserMention nodes in the graph.
type MessageUserMentionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*MessageUserMention, error)
	predicates     []predicate.MessageUserMention
}

var _ ent.Mutation = (*MessageUserMentionMutation)(nil)

// messageusermentionOption allows management of the mutation configuration using functional options.
type messageusermentionOption func(*MessageUserMentionMutation)

// newMessageUserMentionMutation creates new mutation for the MessageUserMention entity.
func newMessageUserMentionMutation(c config, op Op, opts ...messageusermentionOption) *MessageUserMentionMutation {
	m := &MessageUserMentionMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageUserMention,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageUserMentionID sets the ID field of the mutation.
func withMessageUserMentionID(id uuid.UUID) messageusermentionOption {
	return func(m *MessageUserMentionMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageUserMention
		)
		m.oldValue = func(ctx context.Context) (*MessageUserMention, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageUserMention.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageUserMention sets the old MessageUserMention of the mutation.
func withMessageUserMention(node *MessageUserMention) messageusermentionOption {
	return func(m *MessageUserMentionMutation) {
		m.oldValue = func(context.Context) (*MessageUserMention, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageUserMentionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageUserMentionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessageUserMention entities.
func (m *MessageUserMentionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageUserMentionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageUserMentionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageUserMention.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageUserMentionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageUserMentionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageUserMention entity.
// If the MessageUserMention object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageUserMentionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageUserMentionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *MessageUserMentionMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *MessageUserMentionMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *MessageUserMentionMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *MessageUserMentionMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *MessageUserMentionMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *MessageUserMentionMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MessageUserMentionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageUserMentionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageUserMentionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MessageUserMentionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageUserMentionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageUserMentionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MessageUserMentionMutation builder.
func (m *MessageUserMentionMutation) Where(ps ...predicate.MessageUserMention) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageUserMentionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageUserMentionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageUserMention, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageUserMentionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageUserMentionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageUserMention).
func (m *MessageUserMentionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageUserMentionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, messageusermention.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageUserMentionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messageusermention.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageUserMentionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messageusermention.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageUserMention field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageUserMentionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messageusermention.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageUserMention field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageUserMentionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageUserMentionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageUserMentionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageUserMention numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageUserMentionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageUserMentionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageUserMentionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessageUserMention nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageUserMentionMutation) ResetField(name string) error {
	switch name {
	case messageusermention.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageUserMention field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageUserMentionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.message != nil {
		edges = append(edges, messageusermention.EdgeMessage)
	}
	if m.user != nil {
		edges = append(edges, messageusermention.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageUserMentionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messageusermention.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case messageusermention.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageUserMentionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageUserMentionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageUserMentionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessage {
		edges = append(edges, messageusermention.EdgeMessage)
	}
	if m.cleareduser {
		edges = append(edges, messageusermention.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageUserMentionMutation) EdgeCleared(name string) bool {
	switch name {
	case messageusermention.EdgeMessage:
		return m.clearedmessage
	case messageusermention.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageUserMentionMutation) ClearEdge(name string) error {
	switch name {
	case messageusermention.EdgeMessage:
		m.ClearMessage()
		return nil
	case messageusermention.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MessageUserMention unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageUserMentionMutation) ResetEdge(name string) error {
	switch name {
	case messageusermention.EdgeMessage:
		m.ResetMessage()
		return nil
	case messageusermention.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MessageUserMention edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	refresh_token_hash *string
	expires_at         *time.Time
	revoked_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Session, error)
	predicates         []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRefreshTokenHash sets the "refresh_token_hash" field.
func (m *SessionMutation) SetRefreshTokenHash(s string) {
	m.refresh_token_hash = &s
}

// RefreshTokenHash returns the value of the "refresh_token_hash" field in the mutation.
func (m *SessionMutation) RefreshTokenHash() (r string, exists bool) {
	v := m.refresh_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenHash returns the old "refresh_token_hash" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenHash: %w", err)
	}
	return oldValue.RefreshTokenHash, nil
}

// ResetRefreshTokenHash resets all changes to the "refresh_token_hash" field.
func (m *SessionMutation) ResetRefreshTokenHash() {
	m.refresh_token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.refresh_token_hash != nil {
		fields = append(fields, session.FieldRefreshTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldRefreshTokenHash:
		return m.RefreshTokenHash()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldRefreshTokenHash:
		return m.OldRefreshTokenHash(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldRefreshTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenHash(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldRefreshTokenHash:
		m.ResetRefreshTokenHash()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SystemMessageMutation represents an operation that mutates the SystemMessage nodes in the graph.
type SystemMessageMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	kind           *string
	payload        *map[string]interface{}
	created_at     *time.Time
	clearedFields  map[string]struct{}
	channel        *uuid.UUID
	clearedchannel bool
	actor          *uuid.UUID
	clearedactor   bool
	done           bool
	oldValue       func(context.Context) (*SystemMessage, error)
	predicates     []predicate.SystemMessage
}

var _ ent.Mutation = (*SystemMessageMutation)(nil)

// systemmessageOption allows management of the mutation configuration using functional options.
type systemmessageOption func(*SystemMessageMutation)

// newSystemMessageMutation creates new mutation for the SystemMessage entity.
func newSystemMessageMutation(c config, op Op, opts ...systemmessageOption) *SystemMessageMutation {
	m := &SystemMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemMessageID sets the ID field of the mutation.
func withSystemMessageID(id uuid.UUID) systemmessageOption {
	return func(m *SystemMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemMessage
		)
		m.oldValue = func(ctx context.Context) (*SystemMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemMessage sets the old SystemMessage of the mutation.
func withSystemMessage(node *SystemMessage) systemmessageOption {
	return func(m *SystemMessageMutation) {
		m.oldValue = func(context.Context) (*SystemMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemMessage entities.
func (m *SystemMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKind sets the "kind" field.
func (m *SystemMessageMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SystemMessageMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the SystemMessage entity.
// If the SystemMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMessageMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *SystemMessageMutation) ResetKind() {
	m.kind = nil
}

// SetPayload sets the "payload" field.
func (m *SystemMessageMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *SystemMessageMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the SystemMessage entity.
// If the SystemMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMessageMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *SystemMessageMutation) ResetPayload() {
	m.payload = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemMessage entity.
// If the SystemMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *SystemMessageMutation) SetChannelID(id uuid.UUID) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *SystemMessageMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *SystemMessageMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *SystemMessageMutation) ChannelID() (id uuid.UUID, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *SystemMessageMutation) ChannelIDs() (ids []uuid.UUID) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *SystemMessageMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetActorID sets the "actor" edge to the User entity by id.
func (m *SystemMessageMutation) SetActorID(id uuid.UUID) {
	m.actor = &id
}

// ClearActor clears the "actor" edge to the User entity.
func (m *SystemMessageMutation) ClearActor() {
	m.clearedactor = true
}

// ActorCleared reports if the "actor" edge to the User entity was cleared.
func (m *SystemMessageMutation) ActorCleared() bool {
	return m.clearedactor
}

// ActorID returns the "actor" edge ID in the mutation.
func (m *SystemMessageMutation) ActorID() (id uuid.UUID, exists bool) {
	if m.actor != nil {
		return *m.actor, true
	}
	return
}

// ActorIDs returns the "actor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActorID instead. It exists only for internal usage by the builders.
func (m *SystemMessageMutation) ActorIDs() (ids []uuid.UUID) {
	if id := m.actor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActor resets all changes to the "actor" edge.
func (m *SystemMessageMutation) ResetActor() {
	m.actor = nil
	m.clearedactor = false
}

// Where appends a list predicates to the SystemMessageMutation builder.
func (m *SystemMessageMutation) Where(ps ...predicate.SystemMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemMessage).
func (m *SystemMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMessageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.kind != nil {
		fields = append(fields, systemmessage.FieldKind)
	}
	if m.payload != nil {
		fields = append(fields, systemmessage.FieldPayload)
	}
	if m.created_at != nil {
		fields = append(fields, systemmessage.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemmessage.FieldKind:
		return m.Kind()
	case systemmessage.FieldPayload:
		return m.Payload()
	case systemmessage.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemmessage.FieldKind:
		return m.OldKind(ctx)
	case systemmessage.FieldPayload:
		return m.OldPayload(ctx)
	case systemmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemmessage.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case systemmessage.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case systemmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMessageMutation) ResetField(name string) error {
	switch name {
	case systemmessage.FieldKind:
		m.ResetKind()
		return nil
	case systemmessage.FieldPayload:
		m.ResetPayload()
		return nil
	case systemmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel != nil {
		edges = append(edges, systemmessage.EdgeChannel)
	}
	if m.actor != nil {
		edges = append(edges, systemmessage.EdgeActor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemmessage.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case systemmessage.EdgeActor:
		if id := m.actor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel {
		edges = append(edges, systemmessage.EdgeChannel)
	}
	if m.clearedactor {
		edges = append(edges, systemmessage.EdgeActor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case systemmessage.EdgeChannel:
		return m.clearedchannel
	case systemmessage.EdgeActor:
		return m.clearedactor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMessageMutation) ClearEdge(name string) error {
	switch name {
	case systemmessage.EdgeChannel:
		m.ClearChannel()
		return nil
	case systemmessage.EdgeActor:
		m.ClearActor()
		return nil
	}
	return fmt.Errorf("unknown SystemMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMessageMutation) ResetEdge(name string) error {
	switch name {
	case systemmessage.EdgeChannel:
		m.ResetChannel()
		return nil
	case systemmessage.EdgeActor:
		m.ResetActor()
		return nil
	}
	return fmt.Errorf("unknown SystemMessage edge %s", name)
}

// ThreadMetadataMutation represents an operation that mutates the ThreadMetadata nodes in the graph.
type ThreadMetadataMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	reply_count                *int
	addreply_count             *int
	last_reply_at              *time.Time
	participant_user_ids       *[]uuid.UUID
	appendparticipant_user_ids []uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	message                    *uuid.UUID
	clearedmessage             bool
	last_reply_user            *uuid.UUID
	clearedlast_reply_user     bool
	done                       bool
	oldValue                   func(context.Context) (*ThreadMetadata, error)
	predicates                 []predicate.ThreadMetadata
}

var _ ent.Mutation = (*ThreadMetadataMutation)(nil)

// threadmetadataOption allows management of the mutation configuration using functional options.
type threadmetadataOption func(*ThreadMetadataMutation)

// newThreadMetadataMutation creates new mutation for the ThreadMetadata entity.
func newThreadMetadataMutation(c config, op Op, opts ...threadmetadataOption) *ThreadMetadataMutation {
	m := &ThreadMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadMetadataID sets the ID field of the mutation.
func withThreadMetadataID(id uuid.UUID) threadmetadataOption {
	return func(m *ThreadMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadMetadata
		)
		m.oldValue = func(ctx context.Context) (*ThreadMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadMetadata sets the old ThreadMetadata of the mutation.
func withThreadMetadata(node *ThreadMetadata) threadmetadataOption {
	return func(m *ThreadMetadataMutation) {
		m.oldValue = func(context.Context) (*ThreadMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ThreadMetadata entities.
func (m *ThreadMetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMetadataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReplyCount sets the "reply_count" field.
func (m *ThreadMetadataMutation) SetReplyCount(i int) {
	m.reply_count = &i
	m.addreply_count = nil
}

// ReplyCount returns the value of the "reply_count" field in the mutation.
func (m *ThreadMetadataMutation) ReplyCount() (r int, exists bool) {
	v := m.reply_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyCount returns the old "reply_count" field's value of the ThreadMetadata entity.
// If the ThreadMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMetadataMutation) OldReplyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyCount: %w", err)
	}
	return oldValue.ReplyCount, nil
}

// AddReplyCount adds i to the "reply_count" field.
func (m *ThreadMetadataMutation) AddReplyCount(i int) {
	if m.addreply_count != nil {
		*m.addreply_count += i
	} else {
		m.addreply_count = &i
	}
}

// AddedReplyCount returns the value that was added to the "reply_count" field in this mutation.
func (m *ThreadMetadataMutation) AddedReplyCount() (r int, exists bool) {
	v := m.addreply_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplyCount resets all changes to the "reply_count" field.
func (m *ThreadMetadataMutation) ResetReplyCount() {
	m.reply_count = nil
	m.addreply_count = nil
}

// SetLastReplyAt sets the "last_reply_at" field.
func (m *ThreadMetadataMutation) SetLastReplyAt(t time.Time) {
	m.last_reply_at = &t
}

// LastReplyAt returns the value of the "last_reply_at" field in the mutation.
func (m *ThreadMetadataMutation) LastReplyAt() (r time.Time, exists bool) {
	v := m.last_reply_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReplyAt returns the old "last_reply_at" field's value of the ThreadMetadata entity.
// If the ThreadMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMetadataMutation) OldLastReplyAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReplyAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReplyAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReplyAt: %w", err)
	}
	return oldValue.LastReplyAt, nil
}

// ClearLastReplyAt clears the value of the "last_reply_at" field.
func (m *ThreadMetadataMutation) ClearLastReplyAt() {
	m.last_reply_at = nil
	m.clearedFields[threadmetadata.FieldLastReplyAt] = struct{}{}
}

// LastReplyAtCleared returns if the "last_reply_at" field was cleared in this mutation.
func (m *ThreadMetadataMutation) LastReplyAtCleared() bool {
	_, ok := m.clearedFields[threadmetadata.FieldLastReplyAt]
	return ok
}

// ResetLastReplyAt resets all changes to the "last_reply_at" field.
func (m *ThreadMetadataMutation) ResetLastReplyAt() {
	m.last_reply_at = nil
	delete(m.clearedFields, threadmetadata.FieldLastReplyAt)
}

// SetParticipantUserIds sets the "participant_user_ids" field.
func (m *ThreadMetadataMutation) SetParticipantUserIds(u []uuid.UUID) {
	m.participant_user_ids = &u
	m.appendparticipant_user_ids = nil
}

// ParticipantUserIds returns the value of the "participant_user_ids" field in the mutation.
func (m *ThreadMetadataMutation) ParticipantUserIds() (r []uuid.UUID, exists bool) {
	v := m.participant_user_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantUserIds returns the old "participant_user_ids" field's value of the ThreadMetadata entity.
// If the ThreadMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMetadataMutation) OldParticipantUserIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantUserIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantUserIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantUserIds: %w", err)
	}
	return oldValue.ParticipantUserIds, nil
}

// AppendParticipantUserIds adds u to the "participant_user_ids" field.
func (m *ThreadMetadataMutation) AppendParticipantUserIds(u []uuid.UUID) {
	m.appendparticipant_user_ids = append(m.appendparticipant_user_ids, u...)
}

// AppendedParticipantUserIds returns the list of values that were appended to the "participant_user_ids" field in this mutation.
func (m *ThreadMetadataMutation) AppendedParticipantUserIds() ([]uuid.UUID, bool) {
	if len(m.appendparticipant_user_ids) == 0 {
		return nil, false
	}
	return m.appendparticipant_user_ids, true
}

// ResetParticipantUserIds resets all changes to the "participant_user_ids" field.
func (m *ThreadMetadataMutation) ResetParticipantUserIds() {
	m.participant_user_ids = nil
	m.appendparticipant_user_ids = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ThreadMetadata entity.
// If the ThreadMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ThreadMetadata entity.
// If the ThreadMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMessageID sets the "message" edge to the Message entity by id.
func (m *ThreadMetadataMutation) SetMessageID(id uuid.UUID) {
	m.message = &id
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *ThreadMetadataMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *ThreadMetadataMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageID returns the "message" edge ID in the mutation.
func (m *ThreadMetadataMutation) MessageID() (id uuid.UUID, exists bool) {
	if m.message != nil {
		return *m.message, true
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *ThreadMetadataMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *ThreadMetadataMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// SetLastReplyUserID sets the "last_reply_user" edge to the User entity by id.
func (m *ThreadMetadataMutation) SetLastReplyUserID(id uuid.UUID) {
	m.last_reply_user = &id
}

// ClearLastReplyUser clears the "last_reply_user" edge to the User entity.
func (m *ThreadMetadataMutation) ClearLastReplyUser() {
	m.clearedlast_reply_user = true
}

// LastReplyUserCleared reports if the "last_reply_user" edge to the User entity was cleared.
func (m *ThreadMetadataMutation) LastReplyUserCleared() bool {
	return m.clearedlast_reply_user
}

// LastReplyUserID returns the "last_reply_user" edge ID in the mutation.
func (m *ThreadMetadataMutation) LastReplyUserID() (id uuid.UUID, exists bool) {
	if m.last_reply_user != nil {
		return *m.last_reply_user, true
	}
	return
}

// LastReplyUserIDs returns the "last_reply_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastReplyUserID instead. It exists only for internal usage by the builders.
func (m *ThreadMetadataMutation) LastReplyUserIDs() (ids []uuid.UUID) {
	if id := m.last_reply_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastReplyUser resets all changes to the "last_reply_user" edge.
func (m *ThreadMetadataMutation) ResetLastReplyUser() {
	m.last_reply_user = nil
	m.clearedlast_reply_user = false
}

// Where appends a list predicates to the ThreadMetadataMutation builder.
func (m *ThreadMetadataMutation) Where(ps ...predicate.ThreadMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadMetadata).
func (m *ThreadMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMetadataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.reply_count != nil {
		fields = append(fields, threadmetadata.FieldReplyCount)
	}
	if m.last_reply_at != nil {
		fields = append(fields, threadmetadata.FieldLastReplyAt)
	}
	if m.participant_user_ids != nil {
		fields = append(fields, threadmetadata.FieldParticipantUserIds)
	}
	if m.created_at != nil {
		fields = append(fields, threadmetadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, threadmetadata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadmetadata.FieldReplyCount:
		return m.ReplyCount()
	case threadmetadata.FieldLastReplyAt:
		return m.LastReplyAt()
	case threadmetadata.FieldParticipantUserIds:
		return m.ParticipantUserIds()
	case threadmetadata.FieldCreatedAt:
		return m.CreatedAt()
	case threadmetadata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadmetadata.FieldReplyCount:
		return m.OldReplyCount(ctx)
	case threadmetadata.FieldLastReplyAt:
		return m.OldLastReplyAt(ctx)
	case threadmetadata.FieldParticipantUserIds:
		return m.OldParticipantUserIds(ctx)
	case threadmetadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case threadmetadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadmetadata.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyCount(v)
		return nil
	case threadmetadata.FieldLastReplyAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReplyAt(v)
		return nil
	case threadmetadata.FieldParticipantUserIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantUserIds(v)
		return nil
	case threadmetadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case threadmetadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMetadataMutation) AddedFields() []string {
	var fields []string
	if m.addreply_count != nil {
		fields = append(fields, threadmetadata.FieldReplyCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threadmetadata.FieldReplyCount:
		return m.AddedReplyCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threadmetadata.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyCount(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(threadmetadata.FieldLastReplyAt) {
		fields = append(fields, threadmetadata.FieldLastReplyAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMetadataMutation) ClearField(name string) error {
	switch name {
	case threadmetadata.FieldLastReplyAt:
		m.ClearLastReplyAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMetadataMutation) ResetField(name string) error {
	switch name {
	case threadmetadata.FieldReplyCount:
		m.ResetReplyCount()
		return nil
	case threadmetadata.FieldLastReplyAt:
		m.ResetLastReplyAt()
		return nil
	case threadmetadata.FieldParticipantUserIds:
		m.ResetParticipantUserIds()
		return nil
	case threadmetadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case threadmetadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.message != nil {
		edges = append(edges, threadmetadata.EdgeMessage)
	}
	if m.last_reply_user != nil {
		edges = append(edges, threadmetadata.EdgeLastReplyUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadmetadata.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	case threadmetadata.EdgeLastReplyUser:
		if id := m.last_reply_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessage {
		edges = append(edges, threadmetadata.EdgeMessage)
	}
	if m.clearedlast_reply_user {
		edges = append(edges, threadmetadata.EdgeLastReplyUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case threadmetadata.EdgeMessage:
		return m.clearedmessage
	case threadmetadata.EdgeLastReplyUser:
		return m.clearedlast_reply_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMetadataMutation) ClearEdge(name string) error {
	switch name {
	case threadmetadata.EdgeMessage:
		m.ClearMessage()
		return nil
	case threadmetadata.EdgeLastReplyUser:
		m.ClearLastReplyUser()
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMetadataMutation) ResetEdge(name string) error {
	switch name {
	case threadmetadata.EdgeMessage:
		m.ResetMessage()
		return nil
	case threadmetadata.EdgeLastReplyUser:
		m.ResetLastReplyUser()
		return nil
	}
	return fmt.Errorf("unknown ThreadMetadata edge %s", name)
}

// ThreadReadStateMutation represents an operation that mutates the ThreadReadState nodes in the graph.
type ThreadReadStateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	last_read_at  *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	thread        *uuid.UUID
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*ThreadReadState, error)
	predicates    []predicate.ThreadReadState
}

var _ ent.Mutation = (*ThreadReadStateMutation)(nil)

// threadreadstateOption allows management of the mutation configuration using functional options.
type threadreadstateOption func(*ThreadReadStateMutation)

// newThreadReadStateMutation creates new mutation for the ThreadReadState entity.
func newThreadReadStateMutation(c config, op Op, opts ...threadreadstateOption) *ThreadReadStateMutation {
	m := &ThreadReadStateMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadReadState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadReadStateID sets the ID field of the mutation.
func withThreadReadStateID(id uuid.UUID) threadreadstateOption {
	return func(m *ThreadReadStateMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadReadState
		)
		m.oldValue = func(ctx context.Context) (*ThreadReadState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadReadState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadReadState sets the old ThreadReadState of the mutation.
func withThreadReadState(node *ThreadReadState) threadreadstateOption {
	return func(m *ThreadReadStateMutation) {
		m.oldValue = func(context.Context) (*ThreadReadState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadReadStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadReadStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ThreadReadState entities.
func (m *ThreadReadStateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadReadStateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadReadStateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadReadState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastReadAt sets the "last_read_at" field.
func (m *ThreadReadStateMutation) SetLastReadAt(t time.Time) {
	m.last_read_at = &t
}

// LastReadAt returns the value of the "last_read_at" field in the mutation.
func (m *ThreadReadStateMutation) LastReadAt() (r time.Time, exists bool) {
	v := m.last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadAt returns the old "last_read_at" field's value of the ThreadReadState entity.
// If the ThreadReadState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadReadStateMutation) OldLastReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadAt: %w", err)
	}
	return oldValue.LastReadAt, nil
}

// ResetLastReadAt resets all changes to the "last_read_at" field.
func (m *ThreadReadStateMutation) ResetLastReadAt() {
	m.last_read_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadReadStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadReadStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ThreadReadState entity.
// If the ThreadReadState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadReadStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadReadStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadReadStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadReadStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ThreadReadState entity.
// If the ThreadReadState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadReadStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadReadStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ThreadReadStateMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ThreadReadStateMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ThreadReadStateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ThreadReadStateMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ThreadReadStateMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ThreadReadStateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetThreadID sets the "thread" edge to the Message entity by id.
func (m *ThreadReadStateMutation) SetThreadID(id uuid.UUID) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Message entity.
func (m *ThreadReadStateMutation) ClearThread() {
	m.clearedthread = true
}

// ThreadCleared reports if the "thread" edge to the Message entity was cleared.
func (m *ThreadReadStateMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *ThreadReadStateMutation) ThreadID() (id uuid.UUID, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadReadStateMutation) ThreadIDs() (ids []uuid.UUID) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadReadStateMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the ThreadReadStateMutation builder.
func (m *ThreadReadStateMutation) Where(ps ...predicate.ThreadReadState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadReadStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadReadStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadReadState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadReadStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadReadStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadReadState).
func (m *ThreadReadStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadReadStateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.last_read_at != nil {
		fields = append(fields, threadreadstate.FieldLastReadAt)
	}
	if m.created_at != nil {
		fields = append(fields, threadreadstate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, threadreadstate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadReadStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadreadstate.FieldLastReadAt:
		return m.LastReadAt()
	case threadreadstate.FieldCreatedAt:
		return m.CreatedAt()
	case threadreadstate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadReadStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadreadstate.FieldLastReadAt:
		return m.OldLastReadAt(ctx)
	case threadreadstate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case threadreadstate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadReadState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadReadStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadreadstate.FieldLastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadAt(v)
		return nil
	case threadreadstate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case threadreadstate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadReadState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadReadStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadReadStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadReadStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadReadState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadReadStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadReadStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadReadStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadReadState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadReadStateMutation) ResetField(name string) error {
	switch name {
	case threadreadstate.FieldLastReadAt:
		m.ResetLastReadAt()
		return nil
	case threadreadstate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case threadreadstate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadReadState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadReadStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, threadreadstate.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, threadreadstate.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadReadStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadreadstate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case threadreadstate.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadReadStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadReadStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadReadStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, threadreadstate.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, threadreadstate.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadReadStateMutation) EdgeCleared(name string) bool {
	switch name {
	case threadreadstate.EdgeUser:
		return m.cleareduser
	case threadreadstate.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadReadStateMutation) ClearEdge(name string) error {
	switch name {
	case threadreadstate.EdgeUser:
		m.ClearUser()
		return nil
	case threadreadstate.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadReadState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadReadStateMutation) ResetEdge(name string) error {
	switch name {
	case threadreadstate.EdgeUser:
		m.ResetUser()
		return nil
	case threadreadstate.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadReadState edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	email                             *string
	password_hash                     *string
	display_name                      *string
	avatar_url                        *string
	created_at                        *time.Time
	updated_at                        *time.Time
	clearedFields                     map[string]struct{}
	sessions                          map[uuid.UUID]struct{}
	removedsessions                   map[uuid.UUID]struct{}
	clearedsessions                   bool
	created_workspaces                map[uuid.UUID]struct{}
	removedcreated_workspaces         map[uuid.UUID]struct{}
	clearedcreated_workspaces         bool
	workspace_members                 map[uuid.UUID]struct{}
	removedworkspace_members          map[uuid.UUID]struct{}
	clearedworkspace_members          bool
	created_channels                  map[uuid.UUID]struct{}
	removedcreated_channels           map[uuid.UUID]struct{}
	clearedcreated_channels           bool
	channel_members                   map[uuid.UUID]struct{}
	removedchannel_members            map[uuid.UUID]struct{}
	clearedchannel_members            bool
	messages                          map[uuid.UUID]struct{}
	removedmessages                   map[uuid.UUID]struct{}
	clearedmessages                   bool
	message_reactions                 map[uuid.UUID]struct{}
	removedmessage_reactions          map[uuid.UUID]struct{}
	clearedmessage_reactions          bool
	message_bookmarks                 map[uuid.UUID]struct{}
	removedmessage_bookmarks          map[uuid.UUID]struct{}
	clearedmessage_bookmarks          bool
	user_mentions                     map[uuid.UUID]struct{}
	removeduser_mentions              map[uuid.UUID]struct{}
	cleareduser_mentions              bool
	user_group_members                map[uuid.UUID]struct{}
	removeduser_group_members         map[uuid.UUID]struct{}
	cleareduser_group_members         bool
	created_user_groups               map[uuid.UUID]struct{}
	removedcreated_user_groups        map[uuid.UUID]struct{}
	clearedcreated_user_groups        bool
	attachments                       map[uuid.UUID]struct{}
	removedattachments                map[uuid.UUID]struct{}
	clearedattachments                bool
	channel_read_states               map[uuid.UUID]struct{}
	removedchannel_read_states        map[uuid.UUID]struct{}
	clearedchannel_read_states        bool
	thread_metadata_last_reply        map[uuid.UUID]struct{}
	removedthread_metadata_last_reply map[uuid.UUID]struct{}
	clearedthread_metadata_last_reply bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
	predicates                        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddCreatedWorkspaceIDs adds the "created_workspaces" edge to the Workspace entity by ids.
func (m *UserMutation) AddCreatedWorkspaceIDs(ids ...uuid.UUID) {
	if m.created_workspaces == nil {
		m.created_workspaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_workspaces[ids[i]] = struct{}{}
	}
}

// ClearCreatedWorkspaces clears the "created_workspaces" edge to the Workspace entity.
func (m *UserMutation) ClearCreatedWorkspaces() {
	m.clearedcreated_workspaces = true
}

// CreatedWorkspacesCleared reports if the "created_workspaces" edge to the Workspace entity was cleared.
func (m *UserMutation) CreatedWorkspacesCleared() bool {
	return m.clearedcreated_workspaces
}

// RemoveCreatedWorkspaceIDs removes the "created_workspaces" edge to the Workspace entity by IDs.
func (m *UserMutation) RemoveCreatedWorkspaceIDs(ids ...uuid.UUID) {
	if m.removedcreated_workspaces == nil {
		m.removedcreated_workspaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_workspaces, ids[i])
		m.removedcreated_workspaces[ids[i]] = struct{}{}
	}
}

// RemovedCreatedWorkspaces returns the removed IDs of the "created_workspaces" edge to the Workspace entity.
func (m *UserMutation) RemovedCreatedWorkspacesIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_workspaces {
		ids = append(ids, id)
	}
	return
}

// CreatedWorkspacesIDs returns the "created_workspaces" edge IDs in the mutation.
func (m *UserMutation) CreatedWorkspacesIDs() (ids []uuid.UUID) {
	for id := range m.created_workspaces {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedWorkspaces resets all changes to the "created_workspaces" edge.
func (m *UserMutation) ResetCreatedWorkspaces() {
	m.created_workspaces = nil
	m.clearedcreated_workspaces = false
	m.removedcreated_workspaces = nil
}

// AddWorkspaceMemberIDs adds the "workspace_members" edge to the WorkspaceMember entity by ids.
func (m *UserMutation) AddWorkspaceMemberIDs(ids ...uuid.UUID) {
	if m.workspace_members == nil {
		m.workspace_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workspace_members[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceMembers clears the "workspace_members" edge to the WorkspaceMember entity.
func (m *UserMutation) ClearWorkspaceMembers() {
	m.clearedworkspace_members = true
}

// WorkspaceMembersCleared reports if the "workspace_members" edge to the WorkspaceMember entity was cleared.
func (m *UserMutation) WorkspaceMembersCleared() bool {
	return m.clearedworkspace_members
}

// RemoveWorkspaceMemberIDs removes the "workspace_members" edge to the WorkspaceMember entity by IDs.
func (m *UserMutation) RemoveWorkspaceMemberIDs(ids ...uuid.UUID) {
	if m.removedworkspace_members == nil {
		m.removedworkspace_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workspace_members, ids[i])
		m.removedworkspace_members[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceMembers returns the removed IDs of the "workspace_members" edge to the WorkspaceMember entity.
func (m *UserMutation) RemovedWorkspaceMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedworkspace_members {
		ids = append(ids, id)
	}
	return
}

// WorkspaceMembersIDs returns the "workspace_members" edge IDs in the mutation.
func (m *UserMutation) WorkspaceMembersIDs() (ids []uuid.UUID) {
	for id := range m.workspace_members {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceMembers resets all changes to the "workspace_members" edge.
func (m *UserMutation) ResetWorkspaceMembers() {
	m.workspace_members = nil
	m.clearedworkspace_members = false
	m.removedworkspace_members = nil
}

// AddCreatedChannelIDs adds the "created_channels" edge to the Channel entity by ids.
func (m *UserMutation) AddCreatedChannelIDs(ids ...uuid.UUID) {
	if m.created_channels == nil {
		m.created_channels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_channels[ids[i]] = struct{}{}
	}
}

// ClearCreatedChannels clears the "created_channels" edge to the Channel entity.
func (m *UserMutation) ClearCreatedChannels() {
	m.clearedcreated_channels = true
}

// CreatedChannelsCleared reports if the "created_channels" edge to the Channel entity was cleared.
func (m *UserMutation) CreatedChannelsCleared() bool {
	return m.clearedcreated_channels
}

// RemoveCreatedChannelIDs removes the "created_channels" edge to the Channel entity by IDs.
func (m *UserMutation) RemoveCreatedChannelIDs(ids ...uuid.UUID) {
	if m.removedcreated_channels == nil {
		m.removedcreated_channels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_channels, ids[i])
		m.removedcreated_channels[ids[i]] = struct{}{}
	}
}

// RemovedCreatedChannels returns the removed IDs of the "created_channels" edge to the Channel entity.
func (m *UserMutation) RemovedCreatedChannelsIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_channels {
		ids = append(ids, id)
	}
	return
}

// CreatedChannelsIDs returns the "created_channels" edge IDs in the mutation.
func (m *UserMutation) CreatedChannelsIDs() (ids []uuid.UUID) {
	for id := range m.created_channels {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedChannels resets all changes to the "created_channels" edge.
func (m *UserMutation) ResetCreatedChannels() {
	m.created_channels = nil
	m.clearedcreated_channels = false
	m.removedcreated_channels = nil
}

// AddChannelMemberIDs adds the "channel_members" edge to the ChannelMember entity by ids.
func (m *UserMutation) AddChannelMemberIDs(ids ...uuid.UUID) {
	if m.channel_members == nil {
		m.channel_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.channel_members[ids[i]] = struct{}{}
	}
}

// ClearChannelMembers clears the "channel_members" edge to the ChannelMember entity.
func (m *UserMutation) ClearChannelMembers() {
	m.clearedchannel_members = true
}

// ChannelMembersCleared reports if the "channel_members" edge to the ChannelMember entity was cleared.
func (m *UserMutation) ChannelMembersCleared() bool {
	return m.clearedchannel_members
}

// RemoveChannelMemberIDs removes the "channel_members" edge to the ChannelMember entity by IDs.
func (m *UserMutation) RemoveChannelMemberIDs(ids ...uuid.UUID) {
	if m.removedchannel_members == nil {
		m.removedchannel_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.channel_members, ids[i])
		m.removedchannel_members[ids[i]] = struct{}{}
	}
}

// RemovedChannelMembers returns the removed IDs of the "channel_members" edge to the ChannelMember entity.
func (m *UserMutation) RemovedChannelMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedchannel_members {
		ids = append(ids, id)
	}
	return
}

// ChannelMembersIDs returns the "channel_members" edge IDs in the mutation.
func (m *UserMutation) ChannelMembersIDs() (ids []uuid.UUID) {
	for id := range m.channel_members {
		ids = append(ids, id)
	}
	return
}

// ResetChannelMembers resets all changes to the "channel_members" edge.
func (m *UserMutation) ResetChannelMembers() {
	m.channel_members = nil
	m.clearedchannel_members = false
	m.removedchannel_members = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *UserMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *UserMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *UserMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *UserMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *UserMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *UserMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *UserMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddMessageReactionIDs adds the "message_reactions" edge to the MessageReaction entity by ids.
func (m *UserMutation) AddMessageReactionIDs(ids ...uuid.UUID) {
	if m.message_reactions == nil {
		m.message_reactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.message_reactions[ids[i]] = struct{}{}
	}
}

// ClearMessageReactions clears the "message_reactions" edge to the MessageReaction entity.
func (m *UserMutation) ClearMessageReactions() {
	m.clearedmessage_reactions = true
}

// MessageReactionsCleared reports if the "message_reactions" edge to the MessageReaction entity was cleared.
func (m *UserMutation) MessageReactionsCleared() bool {
	return m.clearedmessage_reactions
}

// RemoveMessageReactionIDs removes the "message_reactions" edge to the MessageReaction entity by IDs.
func (m *UserMutation) RemoveMessageReactionIDs(ids ...uuid.UUID) {
	if m.removedmessage_reactions == nil {
		m.removedmessage_reactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.message_reactions, ids[i])
		m.removedmessage_reactions[ids[i]] = struct{}{}
	}
}

// RemovedMessageReactions returns the removed IDs of the "message_reactions" edge to the MessageReaction entity.
func (m *UserMutation) RemovedMessageReactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedmessage_reactions {
		ids = append(ids, id)
	}
	return
}

// MessageReactionsIDs returns the "message_reactions" edge IDs in the mutation.
func (m *UserMutation) MessageReactionsIDs() (ids []uuid.UUID) {
	for id := range m.message_reactions {
		ids = append(ids, id)
	}
	return
}

// ResetMessageReactions resets all changes to the "message_reactions" edge.
func (m *UserMutation) ResetMessageReactions() {
	m.message_reactions = nil
	m.clearedmessage_reactions = false
	m.removedmessage_reactions = nil
}

// AddMessageBookmarkIDs adds the "message_bookmarks" edge to the MessageBookmark entity by ids.
func (m *UserMutation) AddMessageBookmarkIDs(ids ...uuid.UUID) {
	if m.message_bookmarks == nil {
		m.message_bookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.message_bookmarks[ids[i]] = struct{}{}
	}
}

// ClearMessageBookmarks clears the "message_bookmarks" edge to the MessageBookmark entity.
func (m *UserMutation) ClearMessageBookmarks() {
	m.clearedmessage_bookmarks = true
}

// MessageBookmarksCleared reports if the "message_bookmarks" edge to the MessageBookmark entity was cleared.
func (m *UserMutation) MessageBookmarksCleared() bool {
	return m.clearedmessage_bookmarks
}

// RemoveMessageBookmarkIDs removes the "message_bookmarks" edge to the MessageBookmark entity by IDs.
func (m *UserMutation) RemoveMessageBookmarkIDs(ids ...uuid.UUID) {
	if m.removedmessage_bookmarks == nil {
		m.removedmessage_bookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.message_bookmarks, ids[i])
		m.removedmessage_bookmarks[ids[i]] = struct{}{}
	}
}

// RemovedMessageBookmarks returns the removed IDs of the "message_bookmarks" edge to the MessageBookmark entity.
func (m *UserMutation) RemovedMessageBookmarksIDs() (ids []uuid.UUID) {
	for id := range m.removedmessage_bookmarks {
		ids = append(ids, id)
	}
	return
}

// MessageBookmarksIDs returns the "message_bookmarks" edge IDs in the mutation.
func (m *UserMutation) MessageBookmarksIDs() (ids []uuid.UUID) {
	for id := range m.message_bookmarks {
		ids = append(ids, id)
	}
	return
}

// ResetMessageBookmarks resets all changes to the "message_bookmarks" edge.
func (m *UserMutation) ResetMessageBookmarks() {
	m.message_bookmarks = nil
	m.clearedmessage_bookmarks = false
	m.removedmessage_bookmarks = nil
}

// AddUserMentionIDs adds the "user_mentions" edge to the MessageUserMention entity by ids.
func (m *UserMutation) AddUserMentionIDs(ids ...uuid.UUID) {
	if m.user_mentions == nil {
		m.user_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_mentions[ids[i]] = struct{}{}
	}
}

// ClearUserMentions clears the "user_mentions" edge to the MessageUserMention entity.
func (m *UserMutation) ClearUserMentions() {
	m.cleareduser_mentions = true
}

// UserMentionsCleared reports if the "user_mentions" edge to the MessageUserMention entity was cleared.
func (m *UserMutation) UserMentionsCleared() bool {
	return m.cleareduser_mentions
}

// RemoveUserMentionIDs removes the "user_mentions" edge to the MessageUserMention entity by IDs.
func (m *UserMutation) RemoveUserMentionIDs(ids ...uuid.UUID) {
	if m.removeduser_mentions == nil {
		m.removeduser_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_mentions, ids[i])
		m.removeduser_mentions[ids[i]] = struct{}{}
	}
}

// RemovedUserMentions returns the removed IDs of the "user_mentions" edge to the MessageUserMention entity.
func (m *UserMutation) RemovedUserMentionsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_mentions {
		ids = append(ids, id)
	}
	return
}

// UserMentionsIDs returns the "user_mentions" edge IDs in the mutation.
func (m *UserMutation) UserMentionsIDs() (ids []uuid.UUID) {
	for id := range m.user_mentions {
		ids = append(ids, id)
	}
	return
}

// ResetUserMentions resets all changes to the "user_mentions" edge.
func (m *UserMutation) ResetUserMentions() {
	m.user_mentions = nil
	m.cleareduser_mentions = false
	m.removeduser_mentions = nil
}

// AddUserGroupMemberIDs adds the "user_group_members" edge to the UserGroupMember entity by ids.
func (m *UserMutation) AddUserGroupMemberIDs(ids ...uuid.UUID) {
	if m.user_group_members == nil {
		m.user_group_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_group_members[ids[i]] = struct{}{}
	}
}

// ClearUserGroupMembers clears the "user_group_members" edge to the UserGroupMember entity.
func (m *UserMutation) ClearUserGroupMembers() {
	m.cleareduser_group_members = true
}

// UserGroupMembersCleared reports if the "user_group_members" edge to the UserGroupMember entity was cleared.
func (m *UserMutation) UserGroupMembersCleared() bool {
	return m.cleareduser_group_members
}

// RemoveUserGroupMemberIDs removes the "user_group_members" edge to the UserGroupMember entity by IDs.
func (m *UserMutation) RemoveUserGroupMemberIDs(ids ...uuid.UUID) {
	if m.removeduser_group_members == nil {
		m.removeduser_group_members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_group_members, ids[i])
		m.removeduser_group_members[ids[i]] = struct{}{}
	}
}

// RemovedUserGroupMembers returns the removed IDs of the "user_group_members" edge to the UserGroupMember entity.
func (m *UserMutation) RemovedUserGroupMembersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_group_members {
		ids = append(ids, id)
	}
	return
}

// UserGroupMembersIDs returns the "user_group_members" edge IDs in the mutation.
func (m *UserMutation) UserGroupMembersIDs() (ids []uuid.UUID) {
	for id := range m.user_group_members {
		ids = append(ids, id)
	}
	return
}

// ResetUserGroupMembers resets all changes to the "user_group_members" edge.
func (m *UserMutation) ResetUserGroupMembers() {
	m.user_group_members = nil
	m.cleareduser_group_members = false
	m.removeduser_group_members = nil
}

// AddCreatedUserGroupIDs adds the "created_user_groups" edge to the UserGroup entity by ids.
func (m *UserMutation) AddCreatedUserGroupIDs(ids ...uuid.UUID) {
	if m.created_user_groups == nil {
		m.created_user_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_user_groups[ids[i]] = struct{}{}
	}
}

// ClearCreatedUserGroups clears the "created_user_groups" edge to the UserGroup entity.
func (m *UserMutation) ClearCreatedUserGroups() {
	m.clearedcreated_user_groups = true
}

// CreatedUserGroupsCleared reports if the "created_user_groups" edge to the UserGroup entity was cleared.
func (m *UserMutation) CreatedUserGroupsCleared() bool {
	return m.clearedcreated_user_groups
}

// RemoveCreatedUserGroupIDs removes the "created_user_groups" edge to the UserGroup entity by IDs.
func (m *UserMutation) RemoveCreatedUserGroupIDs(ids ...uuid.UUID) {
	if m.removedcreated_user_groups == nil {
		m.removedcreated_user_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_user_groups, ids[i])
		m.removedcreated_user_groups[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUserGroups returns the removed IDs of the "created_user_groups" edge to the UserGroup entity.
func (m *UserMutation) RemovedCreatedUserGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_user_groups {
		ids = append(ids, id)
	}
	return
}

// CreatedUserGroupsIDs returns the "created_user_groups" edge IDs in the mutation.
func (m *UserMutation) CreatedUserGroupsIDs() (ids []uuid.UUID) {
	for id := range m.created_user_groups {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUserGroups resets all changes to the "created_user_groups" edge.
func (m *UserMutation) ResetCreatedUserGroups() {
	m.created_user_groups = nil
	m.clearedcreated_user_groups = false
	m.removedcreated_user_groups = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *UserMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *UserMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *UserMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *UserMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *UserMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *UserMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *UserMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddChannelReadStateIDs adds the "channel_read_states" edge to the ChannelReadState entity by ids.
func (m *UserMutation) AddChannelReadStateIDs(ids ...uuid.UUID) {
	if m.channel_read_states == nil {
		m.channel_read_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.channel_read_states[ids[i]] = struct{}{}
	}
}

// ClearChannelReadStates clears the "channel_read_states" edge to the ChannelReadState entity.
func (m *UserMutation) ClearChannelReadStates() {
	m.clearedchannel_read_states = true
}

// ChannelReadStatesCleared reports if the "channel_read_states" edge to the ChannelReadState entity was cleared.
func (m *UserMutation) ChannelReadStatesCleared() bool {
	return m.clearedchannel_read_states
}

// RemoveChannelReadStateIDs removes the "channel_read_states" edge to the ChannelReadState entity by IDs.
func (m *UserMutation) RemoveChannelReadStateIDs(ids ...uuid.UUID) {
	if m.removedchannel_read_states == nil {
		m.removedchannel_read_states = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.channel_read_states, ids[i])
		m.removedchannel_read_states[ids[i]] = struct{}{}
	}
}

// RemovedChannelReadStates returns the removed IDs of the "channel_read_states" edge to the ChannelReadState entity.
func (m *UserMutation) RemovedChannelReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.removedchannel_read_states {
		ids = append(ids, id)
	}
	return
}

// ChannelReadStatesIDs returns the "channel_read_states" edge IDs in the mutation.
func (m *UserMutation) ChannelReadStatesIDs() (ids []uuid.UUID) {
	for id := range m.channel_read_states {
		ids = append(ids, id)
	}
	return
}

// ResetChannelReadStates resets all changes to the "channel_read_states" edge.
func (m *UserMutation) ResetChannelReadStates() {
	m.channel_read_states = nil
	m.clearedchannel_read_states = false
	m.removedchannel_read_states = nil
}

// AddThreadMetadataLastReplyIDs adds the "thread_metadata_last_reply" edge to the ThreadMetadata entity by ids.
func (m *UserMutation) AddThreadMetadataLastReplyIDs(ids ...uuid.UUID) {
	if m.thread_metadata_last_reply == nil {
		m.thread_metadata_last_reply = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.thread_metadata_last_reply[ids[i]] = struct{}{}
	}
}

// ClearThreadMetadataLastReply clears the "thread_metadata_last_reply" edge to the ThreadMetadata entity.
func (m *UserMutation) ClearThreadMetadataLastReply() {
	m.clearedthread_metadata_last_reply = true
}

// ThreadMetadataLastReplyCleared reports if the "thread_metadata_last_reply" edge to the ThreadMetadata entity was cleared.
func (m *UserMutation) ThreadMetadataLastReplyCleared() bool {
	return m.clearedthread_metadata_last_reply
}

// RemoveThreadMetadataLastReplyIDs removes the "thread_metadata_last_reply" edge to the ThreadMetadata entity by IDs.
func (m *UserMutation) RemoveThreadMetadataLastReplyIDs(ids ...uuid.UUID) {
	if m.removedthread_metadata_last_reply == nil {
		m.removedthread_metadata_last_reply = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.thread_metadata_last_reply, ids[i])
		m.removedthread_metadata_last_reply[ids[i]] = struct{}{}
	}
}

// RemovedThreadMetadataLastReply returns the removed IDs of the "thread_metadata_last_reply" edge to the ThreadMetadata entity.
func (m *UserMutation) RemovedThreadMetadataLastReplyIDs() (ids []uuid.UUID) {
	for id := range m.removedthread_metadata_last_reply {
		ids = append(ids, id)
	}
	return
}

// ThreadMetadataLastReplyIDs returns the "thread_metadata_last_reply" edge IDs in the mutation.
func (m *UserMutation) ThreadMetadataLastReplyIDs() (ids []uuid.UUID) {
	for id := range m.thread_metadata_last_reply {
		ids = append(ids, id)
	}
	return
}

// ResetThreadMetadataLastReply resets all changes to the "thread_metadata_last_reply" edge.
func (m *UserMutation) ResetThreadMetadataLastReply() {
	m.thread_metadata_last_reply = nil
	m.clearedthread_metadata_last_reply = false
	m.removedthread_metadata_last_reply = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.created_workspaces != nil {
		edges = append(edges, user.EdgeCreatedWorkspaces)
	}
	if m.workspace_members != nil {
		edges = append(edges, user.EdgeWorkspaceMembers)
	}
	if m.created_channels != nil {
		edges = append(edges, user.EdgeCreatedChannels)
	}
	if m.channel_members != nil {
		edges = append(edges, user.EdgeChannelMembers)
	}
	if m.messages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.message_reactions != nil {
		edges = append(edges, user.EdgeMessageReactions)
	}
	if m.message_bookmarks != nil {
		edges = append(edges, user.EdgeMessageBookmarks)
	}
	if m.user_mentions != nil {
		edges = append(edges, user.EdgeUserMentions)
	}
	if m.user_group_members != nil {
		edges = append(edges, user.EdgeUserGroupMembers)
	}
	if m.created_user_groups != nil {
		edges = append(edges, user.EdgeCreatedUserGroups)
	}
	if m.attachments != nil {
		edges = append(edges, user.EdgeAttachments)
	}
	if m.channel_read_states != nil {
		edges = append(edges, user.EdgeChannelReadStates)
	}
	if m.thread_metadata_last_reply != nil {
		edges = append(edges, user.EdgeThreadMetadataLastReply)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedWorkspaces:
		ids := make([]ent.Value, 0, len(m.created_workspaces))
		for id := range m.created_workspaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaceMembers:
		ids := make([]ent.Value, 0, len(m.workspace_members))
		for id := range m.workspace_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedChannels:
		ids := make([]ent.Value, 0, len(m.created_channels))
		for id := range m.created_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelMembers:
		ids := make([]ent.Value, 0, len(m.channel_members))
		for id := range m.channel_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessageReactions:
		ids := make([]ent.Value, 0, len(m.message_reactions))
		for id := range m.message_reactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessageBookmarks:
		ids := make([]ent.Value, 0, len(m.message_bookmarks))
		for id := range m.message_bookmarks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMentions:
		ids := make([]ent.Value, 0, len(m.user_mentions))
		for id := range m.user_mentions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserGroupMembers:
		ids := make([]ent.Value, 0, len(m.user_group_members))
		for id := range m.user_group_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUserGroups:
		ids := make([]ent.Value, 0, len(m.created_user_groups))
		for id := range m.created_user_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelReadStates:
		ids := make([]ent.Value, 0, len(m.channel_read_states))
		for id := range m.channel_read_states {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreadMetadataLastReply:
		ids := make([]ent.Value, 0, len(m.thread_metadata_last_reply))
		for id := range m.thread_metadata_last_reply {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedcreated_workspaces != nil {
		edges = append(edges, user.EdgeCreatedWorkspaces)
	}
	if m.removedworkspace_members != nil {
		edges = append(edges, user.EdgeWorkspaceMembers)
	}
	if m.removedcreated_channels != nil {
		edges = append(edges, user.EdgeCreatedChannels)
	}
	if m.removedchannel_members != nil {
		edges = append(edges, user.EdgeChannelMembers)
	}
	if m.removedmessages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.removedmessage_reactions != nil {
		edges = append(edges, user.EdgeMessageReactions)
	}
	if m.removedmessage_bookmarks != nil {
		edges = append(edges, user.EdgeMessageBookmarks)
	}
	if m.removeduser_mentions != nil {
		edges = append(edges, user.EdgeUserMentions)
	}
	if m.removeduser_group_members != nil {
		edges = append(edges, user.EdgeUserGroupMembers)
	}
	if m.removedcreated_user_groups != nil {
		edges = append(edges, user.EdgeCreatedUserGroups)
	}
	if m.removedattachments != nil {
		edges = append(edges, user.EdgeAttachments)
	}
	if m.removedchannel_read_states != nil {
		edges = append(edges, user.EdgeChannelReadStates)
	}
	if m.removedthread_metadata_last_reply != nil {
		edges = append(edges, user.EdgeThreadMetadataLastReply)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedWorkspaces:
		ids := make([]ent.Value, 0, len(m.removedcreated_workspaces))
		for id := range m.removedcreated_workspaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaceMembers:
		ids := make([]ent.Value, 0, len(m.removedworkspace_members))
		for id := range m.removedworkspace_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedChannels:
		ids := make([]ent.Value, 0, len(m.removedcreated_channels))
		for id := range m.removedcreated_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelMembers:
		ids := make([]ent.Value, 0, len(m.removedchannel_members))
		for id := range m.removedchannel_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessageReactions:
		ids := make([]ent.Value, 0, len(m.removedmessage_reactions))
		for id := range m.removedmessage_reactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessageBookmarks:
		ids := make([]ent.Value, 0, len(m.removedmessage_bookmarks))
		for id := range m.removedmessage_bookmarks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMentions:
		ids := make([]ent.Value, 0, len(m.removeduser_mentions))
		for id := range m.removeduser_mentions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserGroupMembers:
		ids := make([]ent.Value, 0, len(m.removeduser_group_members))
		for id := range m.removeduser_group_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUserGroups:
		ids := make([]ent.Value, 0, len(m.removedcreated_user_groups))
		for id := range m.removedcreated_user_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelReadStates:
		ids := make([]ent.Value, 0, len(m.removedchannel_read_states))
		for id := range m.removedchannel_read_states {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreadMetadataLastReply:
		ids := make([]ent.Value, 0, len(m.removedthread_metadata_last_reply))
		for id := range m.removedthread_metadata_last_reply {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedcreated_workspaces {
		edges = append(edges, user.EdgeCreatedWorkspaces)
	}
	if m.clearedworkspace_members {
		edges = append(edges, user.EdgeWorkspaceMembers)
	}
	if m.clearedcreated_channels {
		edges = append(edges, user.EdgeCreatedChannels)
	}
	if m.clearedchannel_members {
		edges = append(edges, user.EdgeChannelMembers)
	}
	if m.clearedmessages {
		edges = append(edges, user.EdgeMessages)
	}
	if m.clearedmessage_reactions {
		edges = append(edges, user.EdgeMessageReactions)
	}
	if m.clearedmessage_bookmarks {
		edges = append(edges, user.EdgeMessageBookmarks)
	}
	if m.cleareduser_mentions {
		edges = append(edges, user.EdgeUserMentions)
	}
	if m.cleareduser_group_members {
		edges = append(edges, user.EdgeUserGroupMembers)
	}
	if m.clearedcreated_user_groups {
		edges = append(edges, user.EdgeCreatedUserGroups)
	}
	if m.clearedattachments {
		edges = append(edges, user.EdgeAttachments)
	}
	if m.clearedchannel_read_states {
		edges = append(edges, user.EdgeChannelReadStates)
	}
	if m.clearedthread_metadata_last_reply {
		edges = append(edges, user.EdgeThreadMetadataLastReply)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeCreatedWorkspaces:
		return m.clearedcreated_workspaces
	case user.EdgeWorkspaceMembers:
		return m.clearedworkspace_members
	case user.EdgeCreatedChannels:
		return m.clearedcreated_channels
	case user.EdgeChannelMembers:
		return m.clearedchannel_members
	case user.EdgeMessages:
		return m.clearedmessages
	case user.EdgeMessageReactions:
		return m.clearedmessage_reactions
	case user.EdgeMessageBookmarks:
		return m.clearedmessage_bookmarks
	case user.EdgeUserMentions:
		return m.cleareduser_mentions
	case user.EdgeUserGroupMembers:
		return m.cleareduser_group_members
	case user.EdgeCreatedUserGroups:
		return m.clearedcreated_user_groups
	case user.EdgeAttachments:
		return m.clearedattachments
	case user.EdgeChannelReadStates:
		return m.clearedchannel_read_states
	case user.EdgeThreadMetadataLastReply:
		return m.clearedthread_metadata_last_reply
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeCreatedWorkspaces:
		m.ResetCreatedWorkspaces()
		return nil
	case user.EdgeWorkspaceMembers:
		m.ResetWorkspaceMembers()
		return nil
	case user.EdgeCreatedChannels:
		m.ResetCreatedChannels()
		return nil
	case user.EdgeChannelMembers:
		m.ResetChannelMembers()
		return nil
	case user.EdgeMessages:
		m.ResetMessages()
		return nil
	case user.EdgeMessageReactions:
		m.ResetMessageReactions()
		return nil
	case user.EdgeMessageBookmarks:
		m.ResetMessageBookmarks()
		return nil
	case user.EdgeUserMentions:
		m.ResetUserMentions()
		return nil
	case user.EdgeUserGroupMembers:
		m.ResetUserGroupMembers()
		return nil
	case user.EdgeCreatedUserGroups:
		m.ResetCreatedUserGroups()
		return nil
	case user.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case user.EdgeChannelReadStates:
		m.ResetChannelReadStates()
		return nil
	case user.EdgeThreadMetadataLastReply:
		m.ResetThreadMetadataLastReply()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserGroupMutation represents an operation that mutates the UserGroup nodes in the graph.
type UserGroupMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	name                  *string
	description           *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	workspace             *uuid.UUID
	clearedworkspace      bool
	created_by            *uuid.UUID
	clearedcreated_by     bool
	members               map[uuid.UUID]struct{}
	removedmembers        map[uuid.UUID]struct{}
	clearedmembers        bool
	group_mentions        map[uuid.UUID]struct{}
	removedgroup_mentions map[uuid.UUID]struct{}
	clearedgroup_mentions bool
	done                  bool
	oldValue              func(context.Context) (*UserGroup, error)
	predicates            []predicate.UserGroup
}

var _ ent.Mutation = (*UserGroupMutation)(nil)

// usergroupOption allows management of the mutation configuration using functional options.
type usergroupOption func(*UserGroupMutation)

// newUserGroupMutation creates new mutation for the UserGroup entity.
func newUserGroupMutation(c config, op Op, opts ...usergroupOption) *UserGroupMutation {
	m := &UserGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGroupID sets the ID field of the mutation.
func withUserGroupID(id uuid.UUID) usergroupOption {
	return func(m *UserGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGroup
		)
		m.oldValue = func(ctx context.Context) (*UserGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGroup sets the old UserGroup of the mutation.
func withUserGroup(node *UserGroup) usergroupOption {
	return func(m *UserGroupMutation) {
		m.oldValue = func(context.Context) (*UserGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserGroup entities.
func (m *UserGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UserGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[usergroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, usergroup.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkspaceID sets the "workspace" edge to the Workspace entity by id.
func (m *UserGroupMutation) SetWorkspaceID(id uuid.UUID) {
	m.workspace = &id
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *UserGroupMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *UserGroupMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceID returns the "workspace" edge ID in the mutation.
func (m *UserGroupMutation) WorkspaceID() (id uuid.UUID, exists bool) {
	if m.workspace != nil {
		return *m.workspace, true
	}
	return
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *UserGroupMutation) WorkspaceIDs() (ids []uuid.UUID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *UserGroupMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *UserGroupMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *UserGroupMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *UserGroupMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *UserGroupMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *UserGroupMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *UserGroupMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddMemberIDs adds the "members" edge to the UserGroupMember entity by ids.
func (m *UserGroupMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the UserGroupMember entity.
func (m *UserGroupMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the UserGroupMember entity was cleared.
func (m *UserGroupMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the UserGroupMember entity by IDs.
func (m *UserGroupMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the UserGroupMember entity.
func (m *UserGroupMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *UserGroupMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *UserGroupMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddGroupMentionIDs adds the "group_mentions" edge to the MessageGroupMention entity by ids.
func (m *UserGroupMutation) AddGroupMentionIDs(ids ...uuid.UUID) {
	if m.group_mentions == nil {
		m.group_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.group_mentions[ids[i]] = struct{}{}
	}
}

// ClearGroupMentions clears the "group_mentions" edge to the MessageGroupMention entity.
func (m *UserGroupMutation) ClearGroupMentions() {
	m.clearedgroup_mentions = true
}

// GroupMentionsCleared reports if the "group_mentions" edge to the MessageGroupMention entity was cleared.
func (m *UserGroupMutation) GroupMentionsCleared() bool {
	return m.clearedgroup_mentions
}

// RemoveGroupMentionIDs removes the "group_mentions" edge to the MessageGroupMention entity by IDs.
func (m *UserGroupMutation) RemoveGroupMentionIDs(ids ...uuid.UUID) {
	if m.removedgroup_mentions == nil {
		m.removedgroup_mentions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.group_mentions, ids[i])
		m.removedgroup_mentions[ids[i]] = struct{}{}
	}
}

// RemovedGroupMentions returns the removed IDs of the "group_mentions" edge to the MessageGroupMention entity.
func (m *UserGroupMutation) RemovedGroupMentionsIDs() (ids []uuid.UUID) {
	for id := range m.removedgroup_mentions {
		ids = append(ids, id)
	}
	return
}

// GroupMentionsIDs returns the "group_mentions" edge IDs in the mutation.
func (m *UserGroupMutation) GroupMentionsIDs() (ids []uuid.UUID) {
	for id := range m.group_mentions {
		ids = append(ids, id)
	}
	return
}

// ResetGroupMentions resets all changes to the "group_mentions" edge.
func (m *UserGroupMutation) ResetGroupMentions() {
	m.group_mentions = nil
	m.clearedgroup_mentions = false
	m.removedgroup_mentions = nil
}

// Where appends a list predicates to the UserGroupMutation builder.
func (m *UserGroupMutation) Where(ps ...predicate.UserGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGroup).
func (m *UserGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, usergroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, usergroup.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, usergroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usergroup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldName:
		return m.Name()
	case usergroup.FieldDescription:
		return m.Description()
	case usergroup.FieldCreatedAt:
		return m.CreatedAt()
	case usergroup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergroup.FieldName:
		return m.OldName(ctx)
	case usergroup.FieldDescription:
		return m.OldDescription(ctx)
	case usergroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usergroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usergroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usergroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usergroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usergroup.FieldDescription) {
		fields = append(fields, usergroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGroupMutation) ClearField(name string) error {
	switch name {
	case usergroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown UserGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGroupMutation) ResetField(name string) error {
	switch name {
	case usergroup.FieldName:
		m.ResetName()
		return nil
	case usergroup.FieldDescription:
		m.ResetDescription()
		return nil
	case usergroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usergroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workspace != nil {
		edges = append(edges, usergroup.EdgeWorkspace)
	}
	if m.created_by != nil {
		edges = append(edges, usergroup.EdgeCreatedBy)
	}
	if m.members != nil {
		edges = append(edges, usergroup.EdgeMembers)
	}
	if m.group_mentions != nil {
		edges = append(edges, usergroup.EdgeGroupMentions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case usergroup.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case usergroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case usergroup.EdgeGroupMentions:
		ids := make([]ent.Value, 0, len(m.group_mentions))
		for id := range m.group_mentions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, usergroup.EdgeMembers)
	}
	if m.removedgroup_mentions != nil {
		edges = append(edges, usergroup.EdgeGroupMentions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case usergroup.EdgeGroupMentions:
		ids := make([]ent.Value, 0, len(m.removedgroup_mentions))
		for id := range m.removedgroup_mentions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkspace {
		edges = append(edges, usergroup.EdgeWorkspace)
	}
	if m.clearedcreated_by {
		edges = append(edges, usergroup.EdgeCreatedBy)
	}
	if m.clearedmembers {
		edges = append(edges, usergroup.EdgeMembers)
	}
	if m.clearedgroup_mentions {
		edges = append(edges, usergroup.EdgeGroupMentions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usergroup.EdgeWorkspace:
		return m.clearedworkspace
	case usergroup.EdgeCreatedBy:
		return m.clearedcreated_by
	case usergroup.EdgeMembers:
		return m.clearedmembers
	case usergroup.EdgeGroupMentions:
		return m.clearedgroup_mentions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGroupMutation) ClearEdge(name string) error {
	switch name {
	case usergroup.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case usergroup.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown UserGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGroupMutation) ResetEdge(name string) error {
	switch name {
	case usergroup.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case usergroup.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usergroup.EdgeMembers:
		m.ResetMembers()
		return nil
	case usergroup.EdgeGroupMentions:
		m.ResetGroupMentions()
		return nil
	}
	return fmt.Errorf("unknown UserGroup edge %s", name)
}

// UserGroupMemberMutation represents an operation that mutates the UserGroupMember nodes in the graph.
type UserGroupMemberMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	joined_at     *time.Time
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserGroupMember, error)
	predicates    []predicate.UserGroupMember
}

var _ ent.Mutation = (*UserGroupMemberMutation)(nil)

// usergroupmemberOption allows management of the mutation configuration using functional options.
type usergroupmemberOption func(*UserGroupMemberMutation)

// newUserGroupMemberMutation creates new mutation for the UserGroupMember entity.
func newUserGroupMemberMutation(c config, op Op, opts ...usergroupmemberOption) *UserGroupMemberMutation {
	m := &UserGroupMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGroupMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGroupMemberID sets the ID field of the mutation.
func withUserGroupMemberID(id uuid.UUID) usergroupmemberOption {
	return func(m *UserGroupMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGroupMember
		)
		m.oldValue = func(ctx context.Context) (*UserGroupMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGroupMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGroupMember sets the old UserGroupMember of the mutation.
func withUserGroupMember(node *UserGroupMember) usergroupmemberOption {
	return func(m *UserGroupMemberMutation) {
		m.oldValue = func(context.Context) (*UserGroupMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGroupMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGroupMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserGroupMember entities.
func (m *UserGroupMemberMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGroupMemberMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGroupMemberMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGroupMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJoinedAt sets the "joined_at" field.
func (m *UserGroupMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *UserGroupMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the UserGroupMember entity.
// If the UserGroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *UserGroupMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetGroupID sets the "group" edge to the UserGroup entity by id.
func (m *UserGroupMemberMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the UserGroup entity.
func (m *UserGroupMemberMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the UserGroup entity was cleared.
func (m *UserGroupMemberMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *UserGroupMemberMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserGroupMemberMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserGroupMemberMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserGroupMemberMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserGroupMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserGroupMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserGroupMemberMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserGroupMemberMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserGroupMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserGroupMemberMutation builder.
func (m *UserGroupMemberMutation) Where(ps ...predicate.UserGroupMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGroupMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGroupMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGroupMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGroupMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGroupMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGroupMember).
func (m *UserGroupMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGroupMemberMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.joined_at != nil {
		fields = append(fields, usergroupmember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGroupMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergroupmember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGroupMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergroupmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserGroupMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergroupmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroupMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGroupMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGroupMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGroupMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGroupMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGroupMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGroupMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserGroupMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGroupMemberMutation) ResetField(name string) error {
	switch name {
	case usergroupmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown UserGroupMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGroupMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, usergroupmember.EdgeGroup)
	}
	if m.user != nil {
		edges = append(edges, usergroupmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGroupMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergroupmember.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usergroupmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGroupMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGroupMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGroupMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, usergroupmember.EdgeGroup)
	}
	if m.cleareduser {
		edges = append(edges, usergroupmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGroupMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case usergroupmember.EdgeGroup:
		return m.clearedgroup
	case usergroupmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGroupMemberMutation) ClearEdge(name string) error {
	switch name {
	case usergroupmember.EdgeGroup:
		m.ClearGroup()
		return nil
	case usergroupmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserGroupMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGroupMemberMutation) ResetEdge(name string) error {
	switch name {
	case usergroupmember.EdgeGroup:
		m.ResetGroup()
		return nil
	case usergroupmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserGroupMember edge %s", name)
}

// UserThreadFollowMutation represents an operation that mutates the UserThreadFollow nodes in the graph.
type UserThreadFollowMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	thread        *uuid.UUID
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*UserThreadFollow, error)
	predicates    []predicate.UserThreadFollow
}

var _ ent.Mutation = (*UserThreadFollowMutation)(nil)

// userthreadfollowOption allows management of the mutation configuration using functional options.
type userthreadfollowOption func(*UserThreadFollowMutation)

// newUserThreadFollowMutation creates new mutation for the UserThreadFollow entity.
func newUserThreadFollowMutation(c config, op Op, opts ...userthreadfollowOption) *UserThreadFollowMutation {
	m := &UserThreadFollowMutation{
		config:        c,
		op:            op,
		typ:           TypeUserThreadFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserThreadFollowID sets the ID field of the mutation.
func withUserThreadFollowID(id uuid.UUID) userthreadfollowOption {
	return func(m *UserThreadFollowMutation) {
		var (
			err   error
			once  sync.Once
			value *UserThreadFollow
		)
		m.oldValue = func(ctx context.Context) (*UserThreadFollow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserThreadFollow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserThreadFollow sets the old UserThreadFollow of the mutation.
func withUserThreadFollow(node *UserThreadFollow) userthreadfollowOption {
	return func(m *UserThreadFollowMutation) {
		m.oldValue = func(context.Context) (*UserThreadFollow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserThreadFollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserThreadFollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserThreadFollow entities.
func (m *UserThreadFollowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserThreadFollowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserThreadFollowMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserThreadFollow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserThreadFollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserThreadFollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserThreadFollow entity.
// If the UserThreadFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserThreadFollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserThreadFollowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserThreadFollowMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserThreadFollowMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserThreadFollowMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserThreadFollowMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserThreadFollowMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserThreadFollowMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetThreadID sets the "thread" edge to the Message entity by id.
func (m *UserThreadFollowMutation) SetThreadID(id uuid.UUID) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Message entity.
func (m *UserThreadFollowMutation) ClearThread() {
	m.clearedthread = true
}

// ThreadCleared reports if the "thread" edge to the Message entity was cleared.
func (m *UserThreadFollowMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *UserThreadFollowMutation) ThreadID() (id uuid.UUID, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *UserThreadFollowMutation) ThreadIDs() (ids []uuid.UUID) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *UserThreadFollowMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the UserThreadFollowMutation builder.
func (m *UserThreadFollowMutation) Where(ps ...predicate.UserThreadFollow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserThreadFollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserThreadFollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserThreadFollow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserThreadFollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserThreadFollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserThreadFollow).
func (m *UserThreadFollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserThreadFollowMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, userthreadfollow.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserThreadFollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userthreadfollow.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserThreadFollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userthreadfollow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserThreadFollow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadFollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userthreadfollow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserThreadFollow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserThreadFollowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserThreadFollowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserThreadFollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserThreadFollow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserThreadFollowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserThreadFollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserThreadFollowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserThreadFollow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserThreadFollowMutation) ResetField(name string) error {
	switch name {
	case userthreadfollow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserThreadFollow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserThreadFollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userthreadfollow.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, userthreadfollow.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserThreadFollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userthreadfollow.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userthreadfollow.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserThreadFollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserThreadFollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserThreadFollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userthreadfollow.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, userthreadfollow.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserThreadFollowMutation) EdgeCleared(name string) bool {
	switch name {
	case userthreadfollow.EdgeUser:
		return m.cleareduser
	case userthreadfollow.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserThreadFollowMutation) ClearEdge(name string) error {
	switch name {
	case userthreadfollow.EdgeUser:
		m.ClearUser()
		return nil
	case userthreadfollow.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadFollow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserThreadFollowMutation) ResetEdge(name string) error {
	switch name {
	case userthreadfollow.EdgeUser:
		m.ResetUser()
		return nil
	case userthreadfollow.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown UserThreadFollow edge %s", name)
}

// WorkspaceMutation represents an operation that mutates the Workspace nodes in the graph.
type WorkspaceMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	description        *string
	icon_url           *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	created_by         *uuid.UUID
	clearedcreated_by  bool
	members            map[uuid.UUID]struct{}
	removedmembers     map[uuid.UUID]struct{}
	clearedmembers     bool
	channels           map[uuid.UUID]struct{}
	removedchannels    map[uuid.UUID]struct{}
	clearedchannels    bool
	user_groups        map[uuid.UUID]struct{}
	removeduser_groups map[uuid.UUID]struct{}
	cleareduser_groups bool
	done               bool
	oldValue           func(context.Context) (*Workspace, error)
	predicates         []predicate.Workspace
}

var _ ent.Mutation = (*WorkspaceMutation)(nil)

// workspaceOption allows management of the mutation configuration using functional options.
type workspaceOption func(*WorkspaceMutation)

// newWorkspaceMutation creates new mutation for the Workspace entity.
func newWorkspaceMutation(c config, op Op, opts ...workspaceOption) *WorkspaceMutation {
	m := &WorkspaceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceID sets the ID field of the mutation.
func withWorkspaceID(id uuid.UUID) workspaceOption {
	return func(m *WorkspaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Workspace
		)
		m.oldValue = func(ctx context.Context) (*Workspace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workspace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspace sets the old Workspace of the mutation.
func withWorkspace(node *Workspace) workspaceOption {
	return func(m *WorkspaceMutation) {
		m.oldValue = func(context.Context) (*Workspace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workspace entities.
func (m *WorkspaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workspace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkspaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkspaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkspaceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkspaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkspaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkspaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workspace.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkspaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workspace.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkspaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workspace.FieldDescription)
}

// SetIconURL sets the "icon_url" field.
func (m *WorkspaceMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *WorkspaceMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *WorkspaceMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[workspace.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *WorkspaceMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[workspace.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *WorkspaceMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, workspace.FieldIconURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *WorkspaceMutation) SetCreatedByID(id uuid.UUID) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *WorkspaceMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *WorkspaceMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *WorkspaceMutation) CreatedByID() (id uuid.UUID, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *WorkspaceMutation) CreatedByIDs() (ids []uuid.UUID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *WorkspaceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddMemberIDs adds the "members" edge to the WorkspaceMember entity by ids.
func (m *WorkspaceMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the WorkspaceMember entity.
func (m *WorkspaceMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the WorkspaceMember entity was cleared.
func (m *WorkspaceMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the WorkspaceMember entity by IDs.
func (m *WorkspaceMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the WorkspaceMember entity.
func (m *WorkspaceMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *WorkspaceMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *WorkspaceMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddChannelIDs adds the "channels" edge to the Channel entity by ids.
func (m *WorkspaceMutation) AddChannelIDs(ids ...uuid.UUID) {
	if m.channels == nil {
		m.channels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the Channel entity.
func (m *WorkspaceMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the Channel entity was cleared.
func (m *WorkspaceMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the Channel entity by IDs.
func (m *WorkspaceMutation) RemoveChannelIDs(ids ...uuid.UUID) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the Channel entity.
func (m *WorkspaceMutation) RemovedChannelsIDs() (ids []uuid.UUID) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *WorkspaceMutation) ChannelsIDs() (ids []uuid.UUID) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *WorkspaceMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddUserGroupIDs adds the "user_groups" edge to the UserGroup entity by ids.
func (m *WorkspaceMutation) AddUserGroupIDs(ids ...uuid.UUID) {
	if m.user_groups == nil {
		m.user_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_groups[ids[i]] = struct{}{}
	}
}

// ClearUserGroups clears the "user_groups" edge to the UserGroup entity.
func (m *WorkspaceMutation) ClearUserGroups() {
	m.cleareduser_groups = true
}

// UserGroupsCleared reports if the "user_groups" edge to the UserGroup entity was cleared.
func (m *WorkspaceMutation) UserGroupsCleared() bool {
	return m.cleareduser_groups
}

// RemoveUserGroupIDs removes the "user_groups" edge to the UserGroup entity by IDs.
func (m *WorkspaceMutation) RemoveUserGroupIDs(ids ...uuid.UUID) {
	if m.removeduser_groups == nil {
		m.removeduser_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_groups, ids[i])
		m.removeduser_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserGroups returns the removed IDs of the "user_groups" edge to the UserGroup entity.
func (m *WorkspaceMutation) RemovedUserGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_groups {
		ids = append(ids, id)
	}
	return
}

// UserGroupsIDs returns the "user_groups" edge IDs in the mutation.
func (m *WorkspaceMutation) UserGroupsIDs() (ids []uuid.UUID) {
	for id := range m.user_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserGroups resets all changes to the "user_groups" edge.
func (m *WorkspaceMutation) ResetUserGroups() {
	m.user_groups = nil
	m.cleareduser_groups = false
	m.removeduser_groups = nil
}

// Where appends a list predicates to the WorkspaceMutation builder.
func (m *WorkspaceMutation) Where(ps ...predicate.Workspace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workspace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workspace).
func (m *WorkspaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, workspace.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workspace.FieldDescription)
	}
	if m.icon_url != nil {
		fields = append(fields, workspace.FieldIconURL)
	}
	if m.created_at != nil {
		fields = append(fields, workspace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspace.FieldName:
		return m.Name()
	case workspace.FieldDescription:
		return m.Description()
	case workspace.FieldIconURL:
		return m.IconURL()
	case workspace.FieldCreatedAt:
		return m.CreatedAt()
	case workspace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspace.FieldName:
		return m.OldName(ctx)
	case workspace.FieldDescription:
		return m.OldDescription(ctx)
	case workspace.FieldIconURL:
		return m.OldIconURL(ctx)
	case workspace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workspace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workspace.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workspace.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case workspace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workspace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workspace.FieldDescription) {
		fields = append(fields, workspace.FieldDescription)
	}
	if m.FieldCleared(workspace.FieldIconURL) {
		fields = append(fields, workspace.FieldIconURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceMutation) ClearField(name string) error {
	switch name {
	case workspace.FieldDescription:
		m.ClearDescription()
		return nil
	case workspace.FieldIconURL:
		m.ClearIconURL()
		return nil
	}
	return fmt.Errorf("unknown Workspace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceMutation) ResetField(name string) error {
	switch name {
	case workspace.FieldName:
		m.ResetName()
		return nil
	case workspace.FieldDescription:
		m.ResetDescription()
		return nil
	case workspace.FieldIconURL:
		m.ResetIconURL()
		return nil
	case workspace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.created_by != nil {
		edges = append(edges, workspace.EdgeCreatedBy)
	}
	if m.members != nil {
		edges = append(edges, workspace.EdgeMembers)
	}
	if m.channels != nil {
		edges = append(edges, workspace.EdgeChannels)
	}
	if m.user_groups != nil {
		edges = append(edges, workspace.EdgeUserGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case workspace.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeUserGroups:
		ids := make([]ent.Value, 0, len(m.user_groups))
		for id := range m.user_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, workspace.EdgeMembers)
	}
	if m.removedchannels != nil {
		edges = append(edges, workspace.EdgeChannels)
	}
	if m.removeduser_groups != nil {
		edges = append(edges, workspace.EdgeUserGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeUserGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_groups))
		for id := range m.removeduser_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreated_by {
		edges = append(edges, workspace.EdgeCreatedBy)
	}
	if m.clearedmembers {
		edges = append(edges, workspace.EdgeMembers)
	}
	if m.clearedchannels {
		edges = append(edges, workspace.EdgeChannels)
	}
	if m.cleareduser_groups {
		edges = append(edges, workspace.EdgeUserGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceMutation) EdgeCleared(name string) bool {
	switch name {
	case workspace.EdgeCreatedBy:
		return m.clearedcreated_by
	case workspace.EdgeMembers:
		return m.clearedmembers
	case workspace.EdgeChannels:
		return m.clearedchannels
	case workspace.EdgeUserGroups:
		return m.cleareduser_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceMutation) ClearEdge(name string) error {
	switch name {
	case workspace.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Workspace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceMutation) ResetEdge(name string) error {
	switch name {
	case workspace.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workspace.EdgeMembers:
		m.ResetMembers()
		return nil
	case workspace.EdgeChannels:
		m.ResetChannels()
		return nil
	case workspace.EdgeUserGroups:
		m.ResetUserGroups()
		return nil
	}
	return fmt.Errorf("unknown Workspace edge %s", name)
}

// WorkspaceMemberMutation represents an operation that mutates the WorkspaceMember nodes in the graph.
type WorkspaceMemberMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	role             *string
	joined_at        *time.Time
	clearedFields    map[string]struct{}
	workspace        *uuid.UUID
	clearedworkspace bool
	user             *uuid.UUID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*WorkspaceMember, error)
	predicates       []predicate.WorkspaceMember
}

var _ ent.Mutation = (*WorkspaceMemberMutation)(nil)

// workspacememberOption allows management of the mutation configuration using functional options.
type workspacememberOption func(*WorkspaceMemberMutation)

// newWorkspaceMemberMutation creates new mutation for the WorkspaceMember entity.
func newWorkspaceMemberMutation(c config, op Op, opts ...workspacememberOption) *WorkspaceMemberMutation {
	m := &WorkspaceMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceMemberID sets the ID field of the mutation.
func withWorkspaceMemberID(id uuid.UUID) workspacememberOption {
	return func(m *WorkspaceMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceMember
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceMember sets the old WorkspaceMember of the mutation.
func withWorkspaceMember(node *WorkspaceMember) workspacememberOption {
	return func(m *WorkspaceMemberMutation) {
		m.oldValue = func(context.Context) (*WorkspaceMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceMember entities.
func (m *WorkspaceMemberMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceMemberMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceMemberMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *WorkspaceMemberMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *WorkspaceMemberMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WorkspaceMember entity.
// If the WorkspaceMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMemberMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *WorkspaceMemberMutation) ResetRole() {
	m.role = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *WorkspaceMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *WorkspaceMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the WorkspaceMember entity.
// If the WorkspaceMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *WorkspaceMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetWorkspaceID sets the "workspace" edge to the Workspace entity by id.
func (m *WorkspaceMemberMutation) SetWorkspaceID(id uuid.UUID) {
	m.workspace = &id
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *WorkspaceMemberMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *WorkspaceMemberMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceID returns the "workspace" edge ID in the mutation.
func (m *WorkspaceMemberMutation) WorkspaceID() (id uuid.UUID, exists bool) {
	if m.workspace != nil {
		return *m.workspace, true
	}
	return
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *WorkspaceMemberMutation) WorkspaceIDs() (ids []uuid.UUID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *WorkspaceMemberMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkspaceMemberMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkspaceMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkspaceMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkspaceMemberMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkspaceMemberMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkspaceMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WorkspaceMemberMutation builder.
func (m *WorkspaceMemberMutation) Where(ps ...predicate.WorkspaceMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkspaceMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkspaceMember).
func (m *WorkspaceMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceMemberMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, workspacemember.FieldRole)
	}
	if m.joined_at != nil {
		fields = append(fields, workspacemember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspacemember.FieldRole:
		return m.Role()
	case workspacemember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspacemember.FieldRole:
		return m.OldRole(ctx)
	case workspacemember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspacemember.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case workspacemember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkspaceMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceMemberMutation) ResetField(name string) error {
	switch name {
	case workspacemember.FieldRole:
		m.ResetRole()
		return nil
	case workspacemember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workspace != nil {
		edges = append(edges, workspacemember.EdgeWorkspace)
	}
	if m.user != nil {
		edges = append(edges, workspacemember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspacemember.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case workspacemember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkspace {
		edges = append(edges, workspacemember.EdgeWorkspace)
	}
	if m.cleareduser {
		edges = append(edges, workspacemember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case workspacemember.EdgeWorkspace:
		return m.clearedworkspace
	case workspacemember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceMemberMutation) ClearEdge(name string) error {
	switch name {
	case workspacemember.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case workspacemember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceMemberMutation) ResetEdge(name string) error {
	switch name {
	case workspacemember.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case workspacemember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceMember edge %s", name)
}
