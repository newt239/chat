// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/newt239/chat/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/newt239/chat/ent/attachment"
	"github.com/newt239/chat/ent/channel"
	"github.com/newt239/chat/ent/channelmember"
	"github.com/newt239/chat/ent/channelreadstate"
	"github.com/newt239/chat/ent/message"
	"github.com/newt239/chat/ent/messagebookmark"
	"github.com/newt239/chat/ent/messagegroupmention"
	"github.com/newt239/chat/ent/messagelink"
	"github.com/newt239/chat/ent/messagereaction"
	"github.com/newt239/chat/ent/messageusermention"
	"github.com/newt239/chat/ent/session"
	"github.com/newt239/chat/ent/threadmetadata"
	"github.com/newt239/chat/ent/user"
	"github.com/newt239/chat/ent/usergroup"
	"github.com/newt239/chat/ent/usergroupmember"
	"github.com/newt239/chat/ent/workspace"
	"github.com/newt239/chat/ent/workspacemember"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Attachment is the client for interacting with the Attachment builders.
	Attachment *AttachmentClient
	// Channel is the client for interacting with the Channel builders.
	Channel *ChannelClient
	// ChannelMember is the client for interacting with the ChannelMember builders.
	ChannelMember *ChannelMemberClient
	// ChannelReadState is the client for interacting with the ChannelReadState builders.
	ChannelReadState *ChannelReadStateClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// MessageBookmark is the client for interacting with the MessageBookmark builders.
	MessageBookmark *MessageBookmarkClient
	// MessageGroupMention is the client for interacting with the MessageGroupMention builders.
	MessageGroupMention *MessageGroupMentionClient
	// MessageLink is the client for interacting with the MessageLink builders.
	MessageLink *MessageLinkClient
	// MessageReaction is the client for interacting with the MessageReaction builders.
	MessageReaction *MessageReactionClient
	// MessageUserMention is the client for interacting with the MessageUserMention builders.
	MessageUserMention *MessageUserMentionClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// ThreadMetadata is the client for interacting with the ThreadMetadata builders.
	ThreadMetadata *ThreadMetadataClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserGroup is the client for interacting with the UserGroup builders.
	UserGroup *UserGroupClient
	// UserGroupMember is the client for interacting with the UserGroupMember builders.
	UserGroupMember *UserGroupMemberClient
	// Workspace is the client for interacting with the Workspace builders.
	Workspace *WorkspaceClient
	// WorkspaceMember is the client for interacting with the WorkspaceMember builders.
	WorkspaceMember *WorkspaceMemberClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Attachment = NewAttachmentClient(c.config)
	c.Channel = NewChannelClient(c.config)
	c.ChannelMember = NewChannelMemberClient(c.config)
	c.ChannelReadState = NewChannelReadStateClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.MessageBookmark = NewMessageBookmarkClient(c.config)
	c.MessageGroupMention = NewMessageGroupMentionClient(c.config)
	c.MessageLink = NewMessageLinkClient(c.config)
	c.MessageReaction = NewMessageReactionClient(c.config)
	c.MessageUserMention = NewMessageUserMentionClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.ThreadMetadata = NewThreadMetadataClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserGroup = NewUserGroupClient(c.config)
	c.UserGroupMember = NewUserGroupMemberClient(c.config)
	c.Workspace = NewWorkspaceClient(c.config)
	c.WorkspaceMember = NewWorkspaceMemberClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Attachment:          NewAttachmentClient(cfg),
		Channel:             NewChannelClient(cfg),
		ChannelMember:       NewChannelMemberClient(cfg),
		ChannelReadState:    NewChannelReadStateClient(cfg),
		Message:             NewMessageClient(cfg),
		MessageBookmark:     NewMessageBookmarkClient(cfg),
		MessageGroupMention: NewMessageGroupMentionClient(cfg),
		MessageLink:         NewMessageLinkClient(cfg),
		MessageReaction:     NewMessageReactionClient(cfg),
		MessageUserMention:  NewMessageUserMentionClient(cfg),
		Session:             NewSessionClient(cfg),
		ThreadMetadata:      NewThreadMetadataClient(cfg),
		User:                NewUserClient(cfg),
		UserGroup:           NewUserGroupClient(cfg),
		UserGroupMember:     NewUserGroupMemberClient(cfg),
		Workspace:           NewWorkspaceClient(cfg),
		WorkspaceMember:     NewWorkspaceMemberClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Attachment:          NewAttachmentClient(cfg),
		Channel:             NewChannelClient(cfg),
		ChannelMember:       NewChannelMemberClient(cfg),
		ChannelReadState:    NewChannelReadStateClient(cfg),
		Message:             NewMessageClient(cfg),
		MessageBookmark:     NewMessageBookmarkClient(cfg),
		MessageGroupMention: NewMessageGroupMentionClient(cfg),
		MessageLink:         NewMessageLinkClient(cfg),
		MessageReaction:     NewMessageReactionClient(cfg),
		MessageUserMention:  NewMessageUserMentionClient(cfg),
		Session:             NewSessionClient(cfg),
		ThreadMetadata:      NewThreadMetadataClient(cfg),
		User:                NewUserClient(cfg),
		UserGroup:           NewUserGroupClient(cfg),
		UserGroupMember:     NewUserGroupMemberClient(cfg),
		Workspace:           NewWorkspaceClient(cfg),
		WorkspaceMember:     NewWorkspaceMemberClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Attachment.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Attachment, c.Channel, c.ChannelMember, c.ChannelReadState, c.Message,
		c.MessageBookmark, c.MessageGroupMention, c.MessageLink, c.MessageReaction,
		c.MessageUserMention, c.Session, c.ThreadMetadata, c.User, c.UserGroup,
		c.UserGroupMember, c.Workspace, c.WorkspaceMember,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Attachment, c.Channel, c.ChannelMember, c.ChannelReadState, c.Message,
		c.MessageBookmark, c.MessageGroupMention, c.MessageLink, c.MessageReaction,
		c.MessageUserMention, c.Session, c.ThreadMetadata, c.User, c.UserGroup,
		c.UserGroupMember, c.Workspace, c.WorkspaceMember,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AttachmentMutation:
		return c.Attachment.mutate(ctx, m)
	case *ChannelMutation:
		return c.Channel.mutate(ctx, m)
	case *ChannelMemberMutation:
		return c.ChannelMember.mutate(ctx, m)
	case *ChannelReadStateMutation:
		return c.ChannelReadState.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *MessageBookmarkMutation:
		return c.MessageBookmark.mutate(ctx, m)
	case *MessageGroupMentionMutation:
		return c.MessageGroupMention.mutate(ctx, m)
	case *MessageLinkMutation:
		return c.MessageLink.mutate(ctx, m)
	case *MessageReactionMutation:
		return c.MessageReaction.mutate(ctx, m)
	case *MessageUserMentionMutation:
		return c.MessageUserMention.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *ThreadMetadataMutation:
		return c.ThreadMetadata.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserGroupMutation:
		return c.UserGroup.mutate(ctx, m)
	case *UserGroupMemberMutation:
		return c.UserGroupMember.mutate(ctx, m)
	case *WorkspaceMutation:
		return c.Workspace.mutate(ctx, m)
	case *WorkspaceMemberMutation:
		return c.WorkspaceMember.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AttachmentClient is a client for the Attachment schema.
type AttachmentClient struct {
	config
}

// NewAttachmentClient returns a client for the Attachment from the given config.
func NewAttachmentClient(c config) *AttachmentClient {
	return &AttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attachment.Hooks(f(g(h())))`.
func (c *AttachmentClient) Use(hooks ...Hook) {
	c.hooks.Attachment = append(c.hooks.Attachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attachment.Intercept(f(g(h())))`.
func (c *AttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attachment = append(c.inters.Attachment, interceptors...)
}

// Create returns a builder for creating a Attachment entity.
func (c *AttachmentClient) Create() *AttachmentCreate {
	mutation := newAttachmentMutation(c.config, OpCreate)
	return &AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attachment entities.
func (c *AttachmentClient) CreateBulk(builders ...*AttachmentCreate) *AttachmentCreateBulk {
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttachmentClient) MapCreateBulk(slice any, setFunc func(*AttachmentCreate, int)) *AttachmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttachmentCreateBulk{err: fmt.Errorf("calling to AttachmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttachmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attachment.
func (c *AttachmentClient) Update() *AttachmentUpdate {
	mutation := newAttachmentMutation(c.config, OpUpdate)
	return &AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttachmentClient) UpdateOne(_m *Attachment) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachment(_m))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttachmentClient) UpdateOneID(id uuid.UUID) *AttachmentUpdateOne {
	mutation := newAttachmentMutation(c.config, OpUpdateOne, withAttachmentID(id))
	return &AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attachment.
func (c *AttachmentClient) Delete() *AttachmentDelete {
	mutation := newAttachmentMutation(c.config, OpDelete)
	return &AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttachmentClient) DeleteOne(_m *Attachment) *AttachmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttachmentClient) DeleteOneID(id uuid.UUID) *AttachmentDeleteOne {
	builder := c.Delete().Where(attachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttachmentDeleteOne{builder}
}

// Query returns a query builder for Attachment.
func (c *AttachmentClient) Query() *AttachmentQuery {
	return &AttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a Attachment entity by its id.
func (c *AttachmentClient) Get(ctx context.Context, id uuid.UUID) (*Attachment, error) {
	return c.Query().Where(attachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttachmentClient) GetX(ctx context.Context, id uuid.UUID) *Attachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a Attachment.
func (c *AttachmentClient) QueryMessage(_m *Attachment) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attachment.Table, attachment.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attachment.MessageTable, attachment.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUploader queries the uploader edge of a Attachment.
func (c *AttachmentClient) QueryUploader(_m *Attachment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attachment.Table, attachment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attachment.UploaderTable, attachment.UploaderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannel queries the channel edge of a Attachment.
func (c *AttachmentClient) QueryChannel(_m *Attachment) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attachment.Table, attachment.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attachment.ChannelTable, attachment.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttachmentClient) Hooks() []Hook {
	return c.hooks.Attachment
}

// Interceptors returns the client interceptors.
func (c *AttachmentClient) Interceptors() []Interceptor {
	return c.inters.Attachment
}

func (c *AttachmentClient) mutate(ctx context.Context, m *AttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attachment mutation op: %q", m.Op())
	}
}

// ChannelClient is a client for the Channel schema.
type ChannelClient struct {
	config
}

// NewChannelClient returns a client for the Channel from the given config.
func NewChannelClient(c config) *ChannelClient {
	return &ChannelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `channel.Hooks(f(g(h())))`.
func (c *ChannelClient) Use(hooks ...Hook) {
	c.hooks.Channel = append(c.hooks.Channel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `channel.Intercept(f(g(h())))`.
func (c *ChannelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Channel = append(c.inters.Channel, interceptors...)
}

// Create returns a builder for creating a Channel entity.
func (c *ChannelClient) Create() *ChannelCreate {
	mutation := newChannelMutation(c.config, OpCreate)
	return &ChannelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Channel entities.
func (c *ChannelClient) CreateBulk(builders ...*ChannelCreate) *ChannelCreateBulk {
	return &ChannelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChannelClient) MapCreateBulk(slice any, setFunc func(*ChannelCreate, int)) *ChannelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChannelCreateBulk{err: fmt.Errorf("calling to ChannelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChannelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChannelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Channel.
func (c *ChannelClient) Update() *ChannelUpdate {
	mutation := newChannelMutation(c.config, OpUpdate)
	return &ChannelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChannelClient) UpdateOne(_m *Channel) *ChannelUpdateOne {
	mutation := newChannelMutation(c.config, OpUpdateOne, withChannel(_m))
	return &ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChannelClient) UpdateOneID(id uuid.UUID) *ChannelUpdateOne {
	mutation := newChannelMutation(c.config, OpUpdateOne, withChannelID(id))
	return &ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Channel.
func (c *ChannelClient) Delete() *ChannelDelete {
	mutation := newChannelMutation(c.config, OpDelete)
	return &ChannelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChannelClient) DeleteOne(_m *Channel) *ChannelDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChannelClient) DeleteOneID(id uuid.UUID) *ChannelDeleteOne {
	builder := c.Delete().Where(channel.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChannelDeleteOne{builder}
}

// Query returns a query builder for Channel.
func (c *ChannelClient) Query() *ChannelQuery {
	return &ChannelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChannel},
		inters: c.Interceptors(),
	}
}

// Get returns a Channel entity by its id.
func (c *ChannelClient) Get(ctx context.Context, id uuid.UUID) (*Channel, error) {
	return c.Query().Where(channel.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChannelClient) GetX(ctx context.Context, id uuid.UUID) *Channel {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkspace queries the workspace edge of a Channel.
func (c *ChannelClient) QueryWorkspace(_m *Channel) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channel.WorkspaceTable, channel.WorkspaceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Channel.
func (c *ChannelClient) QueryCreatedBy(_m *Channel) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channel.CreatedByTable, channel.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Channel.
func (c *ChannelClient) QueryMembers(_m *Channel) *ChannelMemberQuery {
	query := (&ChannelMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(channelmember.Table, channelmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, channel.MembersTable, channel.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a Channel.
func (c *ChannelClient) QueryMessages(_m *Channel) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, channel.MessagesTable, channel.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttachments queries the attachments edge of a Channel.
func (c *ChannelClient) QueryAttachments(_m *Channel) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, channel.AttachmentsTable, channel.AttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReadStates queries the read_states edge of a Channel.
func (c *ChannelClient) QueryReadStates(_m *Channel) *ChannelReadStateQuery {
	query := (&ChannelReadStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channel.Table, channel.FieldID, id),
			sqlgraph.To(channelreadstate.Table, channelreadstate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, channel.ReadStatesTable, channel.ReadStatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChannelClient) Hooks() []Hook {
	return c.hooks.Channel
}

// Interceptors returns the client interceptors.
func (c *ChannelClient) Interceptors() []Interceptor {
	return c.inters.Channel
}

func (c *ChannelClient) mutate(ctx context.Context, m *ChannelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChannelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChannelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChannelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChannelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Channel mutation op: %q", m.Op())
	}
}

// ChannelMemberClient is a client for the ChannelMember schema.
type ChannelMemberClient struct {
	config
}

// NewChannelMemberClient returns a client for the ChannelMember from the given config.
func NewChannelMemberClient(c config) *ChannelMemberClient {
	return &ChannelMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `channelmember.Hooks(f(g(h())))`.
func (c *ChannelMemberClient) Use(hooks ...Hook) {
	c.hooks.ChannelMember = append(c.hooks.ChannelMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `channelmember.Intercept(f(g(h())))`.
func (c *ChannelMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChannelMember = append(c.inters.ChannelMember, interceptors...)
}

// Create returns a builder for creating a ChannelMember entity.
func (c *ChannelMemberClient) Create() *ChannelMemberCreate {
	mutation := newChannelMemberMutation(c.config, OpCreate)
	return &ChannelMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChannelMember entities.
func (c *ChannelMemberClient) CreateBulk(builders ...*ChannelMemberCreate) *ChannelMemberCreateBulk {
	return &ChannelMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChannelMemberClient) MapCreateBulk(slice any, setFunc func(*ChannelMemberCreate, int)) *ChannelMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChannelMemberCreateBulk{err: fmt.Errorf("calling to ChannelMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChannelMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChannelMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChannelMember.
func (c *ChannelMemberClient) Update() *ChannelMemberUpdate {
	mutation := newChannelMemberMutation(c.config, OpUpdate)
	return &ChannelMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChannelMemberClient) UpdateOne(_m *ChannelMember) *ChannelMemberUpdateOne {
	mutation := newChannelMemberMutation(c.config, OpUpdateOne, withChannelMember(_m))
	return &ChannelMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChannelMemberClient) UpdateOneID(id uuid.UUID) *ChannelMemberUpdateOne {
	mutation := newChannelMemberMutation(c.config, OpUpdateOne, withChannelMemberID(id))
	return &ChannelMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChannelMember.
func (c *ChannelMemberClient) Delete() *ChannelMemberDelete {
	mutation := newChannelMemberMutation(c.config, OpDelete)
	return &ChannelMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChannelMemberClient) DeleteOne(_m *ChannelMember) *ChannelMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChannelMemberClient) DeleteOneID(id uuid.UUID) *ChannelMemberDeleteOne {
	builder := c.Delete().Where(channelmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChannelMemberDeleteOne{builder}
}

// Query returns a query builder for ChannelMember.
func (c *ChannelMemberClient) Query() *ChannelMemberQuery {
	return &ChannelMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChannelMember},
		inters: c.Interceptors(),
	}
}

// Get returns a ChannelMember entity by its id.
func (c *ChannelMemberClient) Get(ctx context.Context, id uuid.UUID) (*ChannelMember, error) {
	return c.Query().Where(channelmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChannelMemberClient) GetX(ctx context.Context, id uuid.UUID) *ChannelMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChannel queries the channel edge of a ChannelMember.
func (c *ChannelMemberClient) QueryChannel(_m *ChannelMember) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channelmember.Table, channelmember.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channelmember.ChannelTable, channelmember.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ChannelMember.
func (c *ChannelMemberClient) QueryUser(_m *ChannelMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channelmember.Table, channelmember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channelmember.UserTable, channelmember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChannelMemberClient) Hooks() []Hook {
	return c.hooks.ChannelMember
}

// Interceptors returns the client interceptors.
func (c *ChannelMemberClient) Interceptors() []Interceptor {
	return c.inters.ChannelMember
}

func (c *ChannelMemberClient) mutate(ctx context.Context, m *ChannelMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChannelMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChannelMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChannelMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChannelMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChannelMember mutation op: %q", m.Op())
	}
}

// ChannelReadStateClient is a client for the ChannelReadState schema.
type ChannelReadStateClient struct {
	config
}

// NewChannelReadStateClient returns a client for the ChannelReadState from the given config.
func NewChannelReadStateClient(c config) *ChannelReadStateClient {
	return &ChannelReadStateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `channelreadstate.Hooks(f(g(h())))`.
func (c *ChannelReadStateClient) Use(hooks ...Hook) {
	c.hooks.ChannelReadState = append(c.hooks.ChannelReadState, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `channelreadstate.Intercept(f(g(h())))`.
func (c *ChannelReadStateClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChannelReadState = append(c.inters.ChannelReadState, interceptors...)
}

// Create returns a builder for creating a ChannelReadState entity.
func (c *ChannelReadStateClient) Create() *ChannelReadStateCreate {
	mutation := newChannelReadStateMutation(c.config, OpCreate)
	return &ChannelReadStateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChannelReadState entities.
func (c *ChannelReadStateClient) CreateBulk(builders ...*ChannelReadStateCreate) *ChannelReadStateCreateBulk {
	return &ChannelReadStateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChannelReadStateClient) MapCreateBulk(slice any, setFunc func(*ChannelReadStateCreate, int)) *ChannelReadStateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChannelReadStateCreateBulk{err: fmt.Errorf("calling to ChannelReadStateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChannelReadStateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChannelReadStateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChannelReadState.
func (c *ChannelReadStateClient) Update() *ChannelReadStateUpdate {
	mutation := newChannelReadStateMutation(c.config, OpUpdate)
	return &ChannelReadStateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChannelReadStateClient) UpdateOne(_m *ChannelReadState) *ChannelReadStateUpdateOne {
	mutation := newChannelReadStateMutation(c.config, OpUpdateOne, withChannelReadState(_m))
	return &ChannelReadStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChannelReadStateClient) UpdateOneID(id uuid.UUID) *ChannelReadStateUpdateOne {
	mutation := newChannelReadStateMutation(c.config, OpUpdateOne, withChannelReadStateID(id))
	return &ChannelReadStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChannelReadState.
func (c *ChannelReadStateClient) Delete() *ChannelReadStateDelete {
	mutation := newChannelReadStateMutation(c.config, OpDelete)
	return &ChannelReadStateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChannelReadStateClient) DeleteOne(_m *ChannelReadState) *ChannelReadStateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChannelReadStateClient) DeleteOneID(id uuid.UUID) *ChannelReadStateDeleteOne {
	builder := c.Delete().Where(channelreadstate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChannelReadStateDeleteOne{builder}
}

// Query returns a query builder for ChannelReadState.
func (c *ChannelReadStateClient) Query() *ChannelReadStateQuery {
	return &ChannelReadStateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChannelReadState},
		inters: c.Interceptors(),
	}
}

// Get returns a ChannelReadState entity by its id.
func (c *ChannelReadStateClient) Get(ctx context.Context, id uuid.UUID) (*ChannelReadState, error) {
	return c.Query().Where(channelreadstate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChannelReadStateClient) GetX(ctx context.Context, id uuid.UUID) *ChannelReadState {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChannel queries the channel edge of a ChannelReadState.
func (c *ChannelReadStateClient) QueryChannel(_m *ChannelReadState) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channelreadstate.Table, channelreadstate.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channelreadstate.ChannelTable, channelreadstate.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ChannelReadState.
func (c *ChannelReadStateClient) QueryUser(_m *ChannelReadState) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(channelreadstate.Table, channelreadstate.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, channelreadstate.UserTable, channelreadstate.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChannelReadStateClient) Hooks() []Hook {
	return c.hooks.ChannelReadState
}

// Interceptors returns the client interceptors.
func (c *ChannelReadStateClient) Interceptors() []Interceptor {
	return c.inters.ChannelReadState
}

func (c *ChannelReadStateClient) mutate(ctx context.Context, m *ChannelReadStateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChannelReadStateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChannelReadStateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChannelReadStateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChannelReadStateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChannelReadState mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(_m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(_m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(_m *Message) *MessageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChannel queries the channel edge of a Message.
func (c *MessageClient) QueryChannel(_m *Message) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.ChannelTable, message.ChannelColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Message.
func (c *MessageClient) QueryUser(_m *Message) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.UserTable, message.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Message.
func (c *MessageClient) QueryParent(_m *Message) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.ParentTable, message.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a Message.
func (c *MessageClient) QueryReplies(_m *Message) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.RepliesTable, message.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactions queries the reactions edge of a Message.
func (c *MessageClient) QueryReactions(_m *Message) *MessageReactionQuery {
	query := (&MessageReactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messagereaction.Table, messagereaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.ReactionsTable, message.ReactionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookmarks queries the bookmarks edge of a Message.
func (c *MessageClient) QueryBookmarks(_m *Message) *MessageBookmarkQuery {
	query := (&MessageBookmarkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messagebookmark.Table, messagebookmark.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.BookmarksTable, message.BookmarksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserMentions queries the user_mentions edge of a Message.
func (c *MessageClient) QueryUserMentions(_m *Message) *MessageUserMentionQuery {
	query := (&MessageUserMentionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messageusermention.Table, messageusermention.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.UserMentionsTable, message.UserMentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMentions queries the group_mentions edge of a Message.
func (c *MessageClient) QueryGroupMentions(_m *Message) *MessageGroupMentionQuery {
	query := (&MessageGroupMentionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messagegroupmention.Table, messagegroupmention.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.GroupMentionsTable, message.GroupMentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinks queries the links edge of a Message.
func (c *MessageClient) QueryLinks(_m *Message) *MessageLinkQuery {
	query := (&MessageLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messagelink.Table, messagelink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.LinksTable, message.LinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttachments queries the attachments edge of a Message.
func (c *MessageClient) QueryAttachments(_m *Message) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.AttachmentsTable, message.AttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadMetadata queries the thread_metadata edge of a Message.
func (c *MessageClient) QueryThreadMetadata(_m *Message) *ThreadMetadataQuery {
	query := (&ThreadMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(threadmetadata.Table, threadmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, message.ThreadMetadataTable, message.ThreadMetadataColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// MessageBookmarkClient is a client for the MessageBookmark schema.
type MessageBookmarkClient struct {
	config
}

// NewMessageBookmarkClient returns a client for the MessageBookmark from the given config.
func NewMessageBookmarkClient(c config) *MessageBookmarkClient {
	return &MessageBookmarkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagebookmark.Hooks(f(g(h())))`.
func (c *MessageBookmarkClient) Use(hooks ...Hook) {
	c.hooks.MessageBookmark = append(c.hooks.MessageBookmark, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagebookmark.Intercept(f(g(h())))`.
func (c *MessageBookmarkClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageBookmark = append(c.inters.MessageBookmark, interceptors...)
}

// Create returns a builder for creating a MessageBookmark entity.
func (c *MessageBookmarkClient) Create() *MessageBookmarkCreate {
	mutation := newMessageBookmarkMutation(c.config, OpCreate)
	return &MessageBookmarkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageBookmark entities.
func (c *MessageBookmarkClient) CreateBulk(builders ...*MessageBookmarkCreate) *MessageBookmarkCreateBulk {
	return &MessageBookmarkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageBookmarkClient) MapCreateBulk(slice any, setFunc func(*MessageBookmarkCreate, int)) *MessageBookmarkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageBookmarkCreateBulk{err: fmt.Errorf("calling to MessageBookmarkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageBookmarkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageBookmarkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageBookmark.
func (c *MessageBookmarkClient) Update() *MessageBookmarkUpdate {
	mutation := newMessageBookmarkMutation(c.config, OpUpdate)
	return &MessageBookmarkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageBookmarkClient) UpdateOne(_m *MessageBookmark) *MessageBookmarkUpdateOne {
	mutation := newMessageBookmarkMutation(c.config, OpUpdateOne, withMessageBookmark(_m))
	return &MessageBookmarkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageBookmarkClient) UpdateOneID(id uuid.UUID) *MessageBookmarkUpdateOne {
	mutation := newMessageBookmarkMutation(c.config, OpUpdateOne, withMessageBookmarkID(id))
	return &MessageBookmarkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageBookmark.
func (c *MessageBookmarkClient) Delete() *MessageBookmarkDelete {
	mutation := newMessageBookmarkMutation(c.config, OpDelete)
	return &MessageBookmarkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageBookmarkClient) DeleteOne(_m *MessageBookmark) *MessageBookmarkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageBookmarkClient) DeleteOneID(id uuid.UUID) *MessageBookmarkDeleteOne {
	builder := c.Delete().Where(messagebookmark.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageBookmarkDeleteOne{builder}
}

// Query returns a query builder for MessageBookmark.
func (c *MessageBookmarkClient) Query() *MessageBookmarkQuery {
	return &MessageBookmarkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageBookmark},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageBookmark entity by its id.
func (c *MessageBookmarkClient) Get(ctx context.Context, id uuid.UUID) (*MessageBookmark, error) {
	return c.Query().Where(messagebookmark.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageBookmarkClient) GetX(ctx context.Context, id uuid.UUID) *MessageBookmark {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MessageBookmark.
func (c *MessageBookmarkClient) QueryUser(_m *MessageBookmark) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagebookmark.Table, messagebookmark.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagebookmark.UserTable, messagebookmark.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessage queries the message edge of a MessageBookmark.
func (c *MessageBookmarkClient) QueryMessage(_m *MessageBookmark) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagebookmark.Table, messagebookmark.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagebookmark.MessageTable, messagebookmark.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageBookmarkClient) Hooks() []Hook {
	return c.hooks.MessageBookmark
}

// Interceptors returns the client interceptors.
func (c *MessageBookmarkClient) Interceptors() []Interceptor {
	return c.inters.MessageBookmark
}

func (c *MessageBookmarkClient) mutate(ctx context.Context, m *MessageBookmarkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageBookmarkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageBookmarkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageBookmarkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageBookmarkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageBookmark mutation op: %q", m.Op())
	}
}

// MessageGroupMentionClient is a client for the MessageGroupMention schema.
type MessageGroupMentionClient struct {
	config
}

// NewMessageGroupMentionClient returns a client for the MessageGroupMention from the given config.
func NewMessageGroupMentionClient(c config) *MessageGroupMentionClient {
	return &MessageGroupMentionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagegroupmention.Hooks(f(g(h())))`.
func (c *MessageGroupMentionClient) Use(hooks ...Hook) {
	c.hooks.MessageGroupMention = append(c.hooks.MessageGroupMention, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagegroupmention.Intercept(f(g(h())))`.
func (c *MessageGroupMentionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageGroupMention = append(c.inters.MessageGroupMention, interceptors...)
}

// Create returns a builder for creating a MessageGroupMention entity.
func (c *MessageGroupMentionClient) Create() *MessageGroupMentionCreate {
	mutation := newMessageGroupMentionMutation(c.config, OpCreate)
	return &MessageGroupMentionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageGroupMention entities.
func (c *MessageGroupMentionClient) CreateBulk(builders ...*MessageGroupMentionCreate) *MessageGroupMentionCreateBulk {
	return &MessageGroupMentionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageGroupMentionClient) MapCreateBulk(slice any, setFunc func(*MessageGroupMentionCreate, int)) *MessageGroupMentionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageGroupMentionCreateBulk{err: fmt.Errorf("calling to MessageGroupMentionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageGroupMentionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageGroupMentionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageGroupMention.
func (c *MessageGroupMentionClient) Update() *MessageGroupMentionUpdate {
	mutation := newMessageGroupMentionMutation(c.config, OpUpdate)
	return &MessageGroupMentionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageGroupMentionClient) UpdateOne(_m *MessageGroupMention) *MessageGroupMentionUpdateOne {
	mutation := newMessageGroupMentionMutation(c.config, OpUpdateOne, withMessageGroupMention(_m))
	return &MessageGroupMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageGroupMentionClient) UpdateOneID(id uuid.UUID) *MessageGroupMentionUpdateOne {
	mutation := newMessageGroupMentionMutation(c.config, OpUpdateOne, withMessageGroupMentionID(id))
	return &MessageGroupMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageGroupMention.
func (c *MessageGroupMentionClient) Delete() *MessageGroupMentionDelete {
	mutation := newMessageGroupMentionMutation(c.config, OpDelete)
	return &MessageGroupMentionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageGroupMentionClient) DeleteOne(_m *MessageGroupMention) *MessageGroupMentionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageGroupMentionClient) DeleteOneID(id uuid.UUID) *MessageGroupMentionDeleteOne {
	builder := c.Delete().Where(messagegroupmention.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageGroupMentionDeleteOne{builder}
}

// Query returns a query builder for MessageGroupMention.
func (c *MessageGroupMentionClient) Query() *MessageGroupMentionQuery {
	return &MessageGroupMentionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageGroupMention},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageGroupMention entity by its id.
func (c *MessageGroupMentionClient) Get(ctx context.Context, id uuid.UUID) (*MessageGroupMention, error) {
	return c.Query().Where(messagegroupmention.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageGroupMentionClient) GetX(ctx context.Context, id uuid.UUID) *MessageGroupMention {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a MessageGroupMention.
func (c *MessageGroupMentionClient) QueryMessage(_m *MessageGroupMention) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagegroupmention.Table, messagegroupmention.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagegroupmention.MessageTable, messagegroupmention.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a MessageGroupMention.
func (c *MessageGroupMentionClient) QueryGroup(_m *MessageGroupMention) *UserGroupQuery {
	query := (&UserGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagegroupmention.Table, messagegroupmention.FieldID, id),
			sqlgraph.To(usergroup.Table, usergroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagegroupmention.GroupTable, messagegroupmention.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageGroupMentionClient) Hooks() []Hook {
	return c.hooks.MessageGroupMention
}

// Interceptors returns the client interceptors.
func (c *MessageGroupMentionClient) Interceptors() []Interceptor {
	return c.inters.MessageGroupMention
}

func (c *MessageGroupMentionClient) mutate(ctx context.Context, m *MessageGroupMentionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageGroupMentionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageGroupMentionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageGroupMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageGroupMentionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageGroupMention mutation op: %q", m.Op())
	}
}

// MessageLinkClient is a client for the MessageLink schema.
type MessageLinkClient struct {
	config
}

// NewMessageLinkClient returns a client for the MessageLink from the given config.
func NewMessageLinkClient(c config) *MessageLinkClient {
	return &MessageLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagelink.Hooks(f(g(h())))`.
func (c *MessageLinkClient) Use(hooks ...Hook) {
	c.hooks.MessageLink = append(c.hooks.MessageLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagelink.Intercept(f(g(h())))`.
func (c *MessageLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageLink = append(c.inters.MessageLink, interceptors...)
}

// Create returns a builder for creating a MessageLink entity.
func (c *MessageLinkClient) Create() *MessageLinkCreate {
	mutation := newMessageLinkMutation(c.config, OpCreate)
	return &MessageLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageLink entities.
func (c *MessageLinkClient) CreateBulk(builders ...*MessageLinkCreate) *MessageLinkCreateBulk {
	return &MessageLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageLinkClient) MapCreateBulk(slice any, setFunc func(*MessageLinkCreate, int)) *MessageLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageLinkCreateBulk{err: fmt.Errorf("calling to MessageLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageLink.
func (c *MessageLinkClient) Update() *MessageLinkUpdate {
	mutation := newMessageLinkMutation(c.config, OpUpdate)
	return &MessageLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageLinkClient) UpdateOne(_m *MessageLink) *MessageLinkUpdateOne {
	mutation := newMessageLinkMutation(c.config, OpUpdateOne, withMessageLink(_m))
	return &MessageLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageLinkClient) UpdateOneID(id uuid.UUID) *MessageLinkUpdateOne {
	mutation := newMessageLinkMutation(c.config, OpUpdateOne, withMessageLinkID(id))
	return &MessageLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageLink.
func (c *MessageLinkClient) Delete() *MessageLinkDelete {
	mutation := newMessageLinkMutation(c.config, OpDelete)
	return &MessageLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageLinkClient) DeleteOne(_m *MessageLink) *MessageLinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageLinkClient) DeleteOneID(id uuid.UUID) *MessageLinkDeleteOne {
	builder := c.Delete().Where(messagelink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageLinkDeleteOne{builder}
}

// Query returns a query builder for MessageLink.
func (c *MessageLinkClient) Query() *MessageLinkQuery {
	return &MessageLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageLink},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageLink entity by its id.
func (c *MessageLinkClient) Get(ctx context.Context, id uuid.UUID) (*MessageLink, error) {
	return c.Query().Where(messagelink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageLinkClient) GetX(ctx context.Context, id uuid.UUID) *MessageLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a MessageLink.
func (c *MessageLinkClient) QueryMessage(_m *MessageLink) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagelink.Table, messagelink.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagelink.MessageTable, messagelink.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageLinkClient) Hooks() []Hook {
	return c.hooks.MessageLink
}

// Interceptors returns the client interceptors.
func (c *MessageLinkClient) Interceptors() []Interceptor {
	return c.inters.MessageLink
}

func (c *MessageLinkClient) mutate(ctx context.Context, m *MessageLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageLink mutation op: %q", m.Op())
	}
}

// MessageReactionClient is a client for the MessageReaction schema.
type MessageReactionClient struct {
	config
}

// NewMessageReactionClient returns a client for the MessageReaction from the given config.
func NewMessageReactionClient(c config) *MessageReactionClient {
	return &MessageReactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagereaction.Hooks(f(g(h())))`.
func (c *MessageReactionClient) Use(hooks ...Hook) {
	c.hooks.MessageReaction = append(c.hooks.MessageReaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagereaction.Intercept(f(g(h())))`.
func (c *MessageReactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageReaction = append(c.inters.MessageReaction, interceptors...)
}

// Create returns a builder for creating a MessageReaction entity.
func (c *MessageReactionClient) Create() *MessageReactionCreate {
	mutation := newMessageReactionMutation(c.config, OpCreate)
	return &MessageReactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageReaction entities.
func (c *MessageReactionClient) CreateBulk(builders ...*MessageReactionCreate) *MessageReactionCreateBulk {
	return &MessageReactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageReactionClient) MapCreateBulk(slice any, setFunc func(*MessageReactionCreate, int)) *MessageReactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageReactionCreateBulk{err: fmt.Errorf("calling to MessageReactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageReactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageReactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageReaction.
func (c *MessageReactionClient) Update() *MessageReactionUpdate {
	mutation := newMessageReactionMutation(c.config, OpUpdate)
	return &MessageReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageReactionClient) UpdateOne(_m *MessageReaction) *MessageReactionUpdateOne {
	mutation := newMessageReactionMutation(c.config, OpUpdateOne, withMessageReaction(_m))
	return &MessageReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageReactionClient) UpdateOneID(id uuid.UUID) *MessageReactionUpdateOne {
	mutation := newMessageReactionMutation(c.config, OpUpdateOne, withMessageReactionID(id))
	return &MessageReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageReaction.
func (c *MessageReactionClient) Delete() *MessageReactionDelete {
	mutation := newMessageReactionMutation(c.config, OpDelete)
	return &MessageReactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageReactionClient) DeleteOne(_m *MessageReaction) *MessageReactionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageReactionClient) DeleteOneID(id uuid.UUID) *MessageReactionDeleteOne {
	builder := c.Delete().Where(messagereaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageReactionDeleteOne{builder}
}

// Query returns a query builder for MessageReaction.
func (c *MessageReactionClient) Query() *MessageReactionQuery {
	return &MessageReactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageReaction},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageReaction entity by its id.
func (c *MessageReactionClient) Get(ctx context.Context, id uuid.UUID) (*MessageReaction, error) {
	return c.Query().Where(messagereaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageReactionClient) GetX(ctx context.Context, id uuid.UUID) *MessageReaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a MessageReaction.
func (c *MessageReactionClient) QueryMessage(_m *MessageReaction) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagereaction.Table, messagereaction.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagereaction.MessageTable, messagereaction.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a MessageReaction.
func (c *MessageReactionClient) QueryUser(_m *MessageReaction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messagereaction.Table, messagereaction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messagereaction.UserTable, messagereaction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageReactionClient) Hooks() []Hook {
	return c.hooks.MessageReaction
}

// Interceptors returns the client interceptors.
func (c *MessageReactionClient) Interceptors() []Interceptor {
	return c.inters.MessageReaction
}

func (c *MessageReactionClient) mutate(ctx context.Context, m *MessageReactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageReactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageReactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageReaction mutation op: %q", m.Op())
	}
}

// MessageUserMentionClient is a client for the MessageUserMention schema.
type MessageUserMentionClient struct {
	config
}

// NewMessageUserMentionClient returns a client for the MessageUserMention from the given config.
func NewMessageUserMentionClient(c config) *MessageUserMentionClient {
	return &MessageUserMentionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messageusermention.Hooks(f(g(h())))`.
func (c *MessageUserMentionClient) Use(hooks ...Hook) {
	c.hooks.MessageUserMention = append(c.hooks.MessageUserMention, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messageusermention.Intercept(f(g(h())))`.
func (c *MessageUserMentionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageUserMention = append(c.inters.MessageUserMention, interceptors...)
}

// Create returns a builder for creating a MessageUserMention entity.
func (c *MessageUserMentionClient) Create() *MessageUserMentionCreate {
	mutation := newMessageUserMentionMutation(c.config, OpCreate)
	return &MessageUserMentionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageUserMention entities.
func (c *MessageUserMentionClient) CreateBulk(builders ...*MessageUserMentionCreate) *MessageUserMentionCreateBulk {
	return &MessageUserMentionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageUserMentionClient) MapCreateBulk(slice any, setFunc func(*MessageUserMentionCreate, int)) *MessageUserMentionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageUserMentionCreateBulk{err: fmt.Errorf("calling to MessageUserMentionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageUserMentionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageUserMentionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageUserMention.
func (c *MessageUserMentionClient) Update() *MessageUserMentionUpdate {
	mutation := newMessageUserMentionMutation(c.config, OpUpdate)
	return &MessageUserMentionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageUserMentionClient) UpdateOne(_m *MessageUserMention) *MessageUserMentionUpdateOne {
	mutation := newMessageUserMentionMutation(c.config, OpUpdateOne, withMessageUserMention(_m))
	return &MessageUserMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageUserMentionClient) UpdateOneID(id uuid.UUID) *MessageUserMentionUpdateOne {
	mutation := newMessageUserMentionMutation(c.config, OpUpdateOne, withMessageUserMentionID(id))
	return &MessageUserMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageUserMention.
func (c *MessageUserMentionClient) Delete() *MessageUserMentionDelete {
	mutation := newMessageUserMentionMutation(c.config, OpDelete)
	return &MessageUserMentionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageUserMentionClient) DeleteOne(_m *MessageUserMention) *MessageUserMentionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageUserMentionClient) DeleteOneID(id uuid.UUID) *MessageUserMentionDeleteOne {
	builder := c.Delete().Where(messageusermention.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageUserMentionDeleteOne{builder}
}

// Query returns a query builder for MessageUserMention.
func (c *MessageUserMentionClient) Query() *MessageUserMentionQuery {
	return &MessageUserMentionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageUserMention},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageUserMention entity by its id.
func (c *MessageUserMentionClient) Get(ctx context.Context, id uuid.UUID) (*MessageUserMention, error) {
	return c.Query().Where(messageusermention.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageUserMentionClient) GetX(ctx context.Context, id uuid.UUID) *MessageUserMention {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a MessageUserMention.
func (c *MessageUserMentionClient) QueryMessage(_m *MessageUserMention) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messageusermention.Table, messageusermention.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messageusermention.MessageTable, messageusermention.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a MessageUserMention.
func (c *MessageUserMentionClient) QueryUser(_m *MessageUserMention) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(messageusermention.Table, messageusermention.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, messageusermention.UserTable, messageusermention.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageUserMentionClient) Hooks() []Hook {
	return c.hooks.MessageUserMention
}

// Interceptors returns the client interceptors.
func (c *MessageUserMentionClient) Interceptors() []Interceptor {
	return c.inters.MessageUserMention
}

func (c *MessageUserMentionClient) mutate(ctx context.Context, m *MessageUserMentionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageUserMentionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUserMentionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUserMentionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageUserMentionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageUserMention mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(_m *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// ThreadMetadataClient is a client for the ThreadMetadata schema.
type ThreadMetadataClient struct {
	config
}

// NewThreadMetadataClient returns a client for the ThreadMetadata from the given config.
func NewThreadMetadataClient(c config) *ThreadMetadataClient {
	return &ThreadMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadmetadata.Hooks(f(g(h())))`.
func (c *ThreadMetadataClient) Use(hooks ...Hook) {
	c.hooks.ThreadMetadata = append(c.hooks.ThreadMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadmetadata.Intercept(f(g(h())))`.
func (c *ThreadMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadMetadata = append(c.inters.ThreadMetadata, interceptors...)
}

// Create returns a builder for creating a ThreadMetadata entity.
func (c *ThreadMetadataClient) Create() *ThreadMetadataCreate {
	mutation := newThreadMetadataMutation(c.config, OpCreate)
	return &ThreadMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadMetadata entities.
func (c *ThreadMetadataClient) CreateBulk(builders ...*ThreadMetadataCreate) *ThreadMetadataCreateBulk {
	return &ThreadMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadMetadataClient) MapCreateBulk(slice any, setFunc func(*ThreadMetadataCreate, int)) *ThreadMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadMetadataCreateBulk{err: fmt.Errorf("calling to ThreadMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadMetadata.
func (c *ThreadMetadataClient) Update() *ThreadMetadataUpdate {
	mutation := newThreadMetadataMutation(c.config, OpUpdate)
	return &ThreadMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadMetadataClient) UpdateOne(_m *ThreadMetadata) *ThreadMetadataUpdateOne {
	mutation := newThreadMetadataMutation(c.config, OpUpdateOne, withThreadMetadata(_m))
	return &ThreadMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadMetadataClient) UpdateOneID(id uuid.UUID) *ThreadMetadataUpdateOne {
	mutation := newThreadMetadataMutation(c.config, OpUpdateOne, withThreadMetadataID(id))
	return &ThreadMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadMetadata.
func (c *ThreadMetadataClient) Delete() *ThreadMetadataDelete {
	mutation := newThreadMetadataMutation(c.config, OpDelete)
	return &ThreadMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadMetadataClient) DeleteOne(_m *ThreadMetadata) *ThreadMetadataDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadMetadataClient) DeleteOneID(id uuid.UUID) *ThreadMetadataDeleteOne {
	builder := c.Delete().Where(threadmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadMetadataDeleteOne{builder}
}

// Query returns a query builder for ThreadMetadata.
func (c *ThreadMetadataClient) Query() *ThreadMetadataQuery {
	return &ThreadMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a ThreadMetadata entity by its id.
func (c *ThreadMetadataClient) Get(ctx context.Context, id uuid.UUID) (*ThreadMetadata, error) {
	return c.Query().Where(threadmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadMetadataClient) GetX(ctx context.Context, id uuid.UUID) *ThreadMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessage queries the message edge of a ThreadMetadata.
func (c *ThreadMetadataClient) QueryMessage(_m *ThreadMetadata) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadmetadata.Table, threadmetadata.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, threadmetadata.MessageTable, threadmetadata.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLastReplyUser queries the last_reply_user edge of a ThreadMetadata.
func (c *ThreadMetadataClient) QueryLastReplyUser(_m *ThreadMetadata) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadmetadata.Table, threadmetadata.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, threadmetadata.LastReplyUserTable, threadmetadata.LastReplyUserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadMetadataClient) Hooks() []Hook {
	return c.hooks.ThreadMetadata
}

// Interceptors returns the client interceptors.
func (c *ThreadMetadataClient) Interceptors() []Interceptor {
	return c.inters.ThreadMetadata
}

func (c *ThreadMetadataClient) mutate(ctx context.Context, m *ThreadMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadMetadata mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedWorkspaces queries the created_workspaces edge of a User.
func (c *UserClient) QueryCreatedWorkspaces(_m *User) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.CreatedWorkspacesTable, user.CreatedWorkspacesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspaceMembers queries the workspace_members edge of a User.
func (c *UserClient) QueryWorkspaceMembers(_m *User) *WorkspaceMemberQuery {
	query := (&WorkspaceMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workspacemember.Table, workspacemember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.WorkspaceMembersTable, user.WorkspaceMembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedChannels queries the created_channels edge of a User.
func (c *UserClient) QueryCreatedChannels(_m *User) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.CreatedChannelsTable, user.CreatedChannelsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannelMembers queries the channel_members edge of a User.
func (c *UserClient) QueryChannelMembers(_m *User) *ChannelMemberQuery {
	query := (&ChannelMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(channelmember.Table, channelmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ChannelMembersTable, user.ChannelMembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a User.
func (c *UserClient) QueryMessages(_m *User) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.MessagesTable, user.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessageReactions queries the message_reactions edge of a User.
func (c *UserClient) QueryMessageReactions(_m *User) *MessageReactionQuery {
	query := (&MessageReactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(messagereaction.Table, messagereaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.MessageReactionsTable, user.MessageReactionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessageBookmarks queries the message_bookmarks edge of a User.
func (c *UserClient) QueryMessageBookmarks(_m *User) *MessageBookmarkQuery {
	query := (&MessageBookmarkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(messagebookmark.Table, messagebookmark.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.MessageBookmarksTable, user.MessageBookmarksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserMentions queries the user_mentions edge of a User.
func (c *UserClient) QueryUserMentions(_m *User) *MessageUserMentionQuery {
	query := (&MessageUserMentionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(messageusermention.Table, messageusermention.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserMentionsTable, user.UserMentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserGroupMembers queries the user_group_members edge of a User.
func (c *UserClient) QueryUserGroupMembers(_m *User) *UserGroupMemberQuery {
	query := (&UserGroupMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usergroupmember.Table, usergroupmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserGroupMembersTable, user.UserGroupMembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedUserGroups queries the created_user_groups edge of a User.
func (c *UserClient) QueryCreatedUserGroups(_m *User) *UserGroupQuery {
	query := (&UserGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usergroup.Table, usergroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.CreatedUserGroupsTable, user.CreatedUserGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttachments queries the attachments edge of a User.
func (c *UserClient) QueryAttachments(_m *User) *AttachmentQuery {
	query := (&AttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(attachment.Table, attachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.AttachmentsTable, user.AttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannelReadStates queries the channel_read_states edge of a User.
func (c *UserClient) QueryChannelReadStates(_m *User) *ChannelReadStateQuery {
	query := (&ChannelReadStateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(channelreadstate.Table, channelreadstate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ChannelReadStatesTable, user.ChannelReadStatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadMetadataLastReply queries the thread_metadata_last_reply edge of a User.
func (c *UserClient) QueryThreadMetadataLastReply(_m *User) *ThreadMetadataQuery {
	query := (&ThreadMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(threadmetadata.Table, threadmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ThreadMetadataLastReplyTable, user.ThreadMetadataLastReplyColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserGroupClient is a client for the UserGroup schema.
type UserGroupClient struct {
	config
}

// NewUserGroupClient returns a client for the UserGroup from the given config.
func NewUserGroupClient(c config) *UserGroupClient {
	return &UserGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usergroup.Hooks(f(g(h())))`.
func (c *UserGroupClient) Use(hooks ...Hook) {
	c.hooks.UserGroup = append(c.hooks.UserGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usergroup.Intercept(f(g(h())))`.
func (c *UserGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserGroup = append(c.inters.UserGroup, interceptors...)
}

// Create returns a builder for creating a UserGroup entity.
func (c *UserGroupClient) Create() *UserGroupCreate {
	mutation := newUserGroupMutation(c.config, OpCreate)
	return &UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserGroup entities.
func (c *UserGroupClient) CreateBulk(builders ...*UserGroupCreate) *UserGroupCreateBulk {
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserGroupClient) MapCreateBulk(slice any, setFunc func(*UserGroupCreate, int)) *UserGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserGroupCreateBulk{err: fmt.Errorf("calling to UserGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserGroup.
func (c *UserGroupClient) Update() *UserGroupUpdate {
	mutation := newUserGroupMutation(c.config, OpUpdate)
	return &UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserGroupClient) UpdateOne(_m *UserGroup) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroup(_m))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserGroupClient) UpdateOneID(id uuid.UUID) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroupID(id))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserGroup.
func (c *UserGroupClient) Delete() *UserGroupDelete {
	mutation := newUserGroupMutation(c.config, OpDelete)
	return &UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserGroupClient) DeleteOne(_m *UserGroup) *UserGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserGroupClient) DeleteOneID(id uuid.UUID) *UserGroupDeleteOne {
	builder := c.Delete().Where(usergroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserGroupDeleteOne{builder}
}

// Query returns a query builder for UserGroup.
func (c *UserGroupClient) Query() *UserGroupQuery {
	return &UserGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a UserGroup entity by its id.
func (c *UserGroupClient) Get(ctx context.Context, id uuid.UUID) (*UserGroup, error) {
	return c.Query().Where(usergroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserGroupClient) GetX(ctx context.Context, id uuid.UUID) *UserGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkspace queries the workspace edge of a UserGroup.
func (c *UserGroupClient) QueryWorkspace(_m *UserGroup) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroup.Table, usergroup.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usergroup.WorkspaceTable, usergroup.WorkspaceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a UserGroup.
func (c *UserGroupClient) QueryCreatedBy(_m *UserGroup) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroup.Table, usergroup.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usergroup.CreatedByTable, usergroup.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a UserGroup.
func (c *UserGroupClient) QueryMembers(_m *UserGroup) *UserGroupMemberQuery {
	query := (&UserGroupMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroup.Table, usergroup.FieldID, id),
			sqlgraph.To(usergroupmember.Table, usergroupmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, usergroup.MembersTable, usergroup.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMentions queries the group_mentions edge of a UserGroup.
func (c *UserGroupClient) QueryGroupMentions(_m *UserGroup) *MessageGroupMentionQuery {
	query := (&MessageGroupMentionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroup.Table, usergroup.FieldID, id),
			sqlgraph.To(messagegroupmention.Table, messagegroupmention.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, usergroup.GroupMentionsTable, usergroup.GroupMentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserGroupClient) Hooks() []Hook {
	return c.hooks.UserGroup
}

// Interceptors returns the client interceptors.
func (c *UserGroupClient) Interceptors() []Interceptor {
	return c.inters.UserGroup
}

func (c *UserGroupClient) mutate(ctx context.Context, m *UserGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserGroup mutation op: %q", m.Op())
	}
}

// UserGroupMemberClient is a client for the UserGroupMember schema.
type UserGroupMemberClient struct {
	config
}

// NewUserGroupMemberClient returns a client for the UserGroupMember from the given config.
func NewUserGroupMemberClient(c config) *UserGroupMemberClient {
	return &UserGroupMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usergroupmember.Hooks(f(g(h())))`.
func (c *UserGroupMemberClient) Use(hooks ...Hook) {
	c.hooks.UserGroupMember = append(c.hooks.UserGroupMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usergroupmember.Intercept(f(g(h())))`.
func (c *UserGroupMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserGroupMember = append(c.inters.UserGroupMember, interceptors...)
}

// Create returns a builder for creating a UserGroupMember entity.
func (c *UserGroupMemberClient) Create() *UserGroupMemberCreate {
	mutation := newUserGroupMemberMutation(c.config, OpCreate)
	return &UserGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserGroupMember entities.
func (c *UserGroupMemberClient) CreateBulk(builders ...*UserGroupMemberCreate) *UserGroupMemberCreateBulk {
	return &UserGroupMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserGroupMemberClient) MapCreateBulk(slice any, setFunc func(*UserGroupMemberCreate, int)) *UserGroupMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserGroupMemberCreateBulk{err: fmt.Errorf("calling to UserGroupMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserGroupMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserGroupMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserGroupMember.
func (c *UserGroupMemberClient) Update() *UserGroupMemberUpdate {
	mutation := newUserGroupMemberMutation(c.config, OpUpdate)
	return &UserGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserGroupMemberClient) UpdateOne(_m *UserGroupMember) *UserGroupMemberUpdateOne {
	mutation := newUserGroupMemberMutation(c.config, OpUpdateOne, withUserGroupMember(_m))
	return &UserGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserGroupMemberClient) UpdateOneID(id uuid.UUID) *UserGroupMemberUpdateOne {
	mutation := newUserGroupMemberMutation(c.config, OpUpdateOne, withUserGroupMemberID(id))
	return &UserGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserGroupMember.
func (c *UserGroupMemberClient) Delete() *UserGroupMemberDelete {
	mutation := newUserGroupMemberMutation(c.config, OpDelete)
	return &UserGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserGroupMemberClient) DeleteOne(_m *UserGroupMember) *UserGroupMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserGroupMemberClient) DeleteOneID(id uuid.UUID) *UserGroupMemberDeleteOne {
	builder := c.Delete().Where(usergroupmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserGroupMemberDeleteOne{builder}
}

// Query returns a query builder for UserGroupMember.
func (c *UserGroupMemberClient) Query() *UserGroupMemberQuery {
	return &UserGroupMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserGroupMember},
		inters: c.Interceptors(),
	}
}

// Get returns a UserGroupMember entity by its id.
func (c *UserGroupMemberClient) Get(ctx context.Context, id uuid.UUID) (*UserGroupMember, error) {
	return c.Query().Where(usergroupmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserGroupMemberClient) GetX(ctx context.Context, id uuid.UUID) *UserGroupMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a UserGroupMember.
func (c *UserGroupMemberClient) QueryGroup(_m *UserGroupMember) *UserGroupQuery {
	query := (&UserGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroupmember.Table, usergroupmember.FieldID, id),
			sqlgraph.To(usergroup.Table, usergroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usergroupmember.GroupTable, usergroupmember.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a UserGroupMember.
func (c *UserGroupMemberClient) QueryUser(_m *UserGroupMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usergroupmember.Table, usergroupmember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usergroupmember.UserTable, usergroupmember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserGroupMemberClient) Hooks() []Hook {
	return c.hooks.UserGroupMember
}

// Interceptors returns the client interceptors.
func (c *UserGroupMemberClient) Interceptors() []Interceptor {
	return c.inters.UserGroupMember
}

func (c *UserGroupMemberClient) mutate(ctx context.Context, m *UserGroupMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserGroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserGroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserGroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserGroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserGroupMember mutation op: %q", m.Op())
	}
}

// WorkspaceClient is a client for the Workspace schema.
type WorkspaceClient struct {
	config
}

// NewWorkspaceClient returns a client for the Workspace from the given config.
func NewWorkspaceClient(c config) *WorkspaceClient {
	return &WorkspaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workspace.Hooks(f(g(h())))`.
func (c *WorkspaceClient) Use(hooks ...Hook) {
	c.hooks.Workspace = append(c.hooks.Workspace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workspace.Intercept(f(g(h())))`.
func (c *WorkspaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workspace = append(c.inters.Workspace, interceptors...)
}

// Create returns a builder for creating a Workspace entity.
func (c *WorkspaceClient) Create() *WorkspaceCreate {
	mutation := newWorkspaceMutation(c.config, OpCreate)
	return &WorkspaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workspace entities.
func (c *WorkspaceClient) CreateBulk(builders ...*WorkspaceCreate) *WorkspaceCreateBulk {
	return &WorkspaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkspaceClient) MapCreateBulk(slice any, setFunc func(*WorkspaceCreate, int)) *WorkspaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkspaceCreateBulk{err: fmt.Errorf("calling to WorkspaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkspaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkspaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workspace.
func (c *WorkspaceClient) Update() *WorkspaceUpdate {
	mutation := newWorkspaceMutation(c.config, OpUpdate)
	return &WorkspaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkspaceClient) UpdateOne(_m *Workspace) *WorkspaceUpdateOne {
	mutation := newWorkspaceMutation(c.config, OpUpdateOne, withWorkspace(_m))
	return &WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkspaceClient) UpdateOneID(id uuid.UUID) *WorkspaceUpdateOne {
	mutation := newWorkspaceMutation(c.config, OpUpdateOne, withWorkspaceID(id))
	return &WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workspace.
func (c *WorkspaceClient) Delete() *WorkspaceDelete {
	mutation := newWorkspaceMutation(c.config, OpDelete)
	return &WorkspaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkspaceClient) DeleteOne(_m *Workspace) *WorkspaceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkspaceClient) DeleteOneID(id uuid.UUID) *WorkspaceDeleteOne {
	builder := c.Delete().Where(workspace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkspaceDeleteOne{builder}
}

// Query returns a query builder for Workspace.
func (c *WorkspaceClient) Query() *WorkspaceQuery {
	return &WorkspaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkspace},
		inters: c.Interceptors(),
	}
}

// Get returns a Workspace entity by its id.
func (c *WorkspaceClient) Get(ctx context.Context, id uuid.UUID) (*Workspace, error) {
	return c.Query().Where(workspace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkspaceClient) GetX(ctx context.Context, id uuid.UUID) *Workspace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreatedBy queries the created_by edge of a Workspace.
func (c *WorkspaceClient) QueryCreatedBy(_m *Workspace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workspace.CreatedByTable, workspace.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Workspace.
func (c *WorkspaceClient) QueryMembers(_m *Workspace) *WorkspaceMemberQuery {
	query := (&WorkspaceMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(workspacemember.Table, workspacemember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workspace.MembersTable, workspace.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChannels queries the channels edge of a Workspace.
func (c *WorkspaceClient) QueryChannels(_m *Workspace) *ChannelQuery {
	query := (&ChannelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(channel.Table, channel.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workspace.ChannelsTable, workspace.ChannelsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserGroups queries the user_groups edge of a Workspace.
func (c *WorkspaceClient) QueryUserGroups(_m *Workspace) *UserGroupQuery {
	query := (&UserGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(usergroup.Table, usergroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workspace.UserGroupsTable, workspace.UserGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkspaceClient) Hooks() []Hook {
	return c.hooks.Workspace
}

// Interceptors returns the client interceptors.
func (c *WorkspaceClient) Interceptors() []Interceptor {
	return c.inters.Workspace
}

func (c *WorkspaceClient) mutate(ctx context.Context, m *WorkspaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkspaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkspaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkspaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Workspace mutation op: %q", m.Op())
	}
}

// WorkspaceMemberClient is a client for the WorkspaceMember schema.
type WorkspaceMemberClient struct {
	config
}

// NewWorkspaceMemberClient returns a client for the WorkspaceMember from the given config.
func NewWorkspaceMemberClient(c config) *WorkspaceMemberClient {
	return &WorkspaceMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workspacemember.Hooks(f(g(h())))`.
func (c *WorkspaceMemberClient) Use(hooks ...Hook) {
	c.hooks.WorkspaceMember = append(c.hooks.WorkspaceMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workspacemember.Intercept(f(g(h())))`.
func (c *WorkspaceMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkspaceMember = append(c.inters.WorkspaceMember, interceptors...)
}

// Create returns a builder for creating a WorkspaceMember entity.
func (c *WorkspaceMemberClient) Create() *WorkspaceMemberCreate {
	mutation := newWorkspaceMemberMutation(c.config, OpCreate)
	return &WorkspaceMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkspaceMember entities.
func (c *WorkspaceMemberClient) CreateBulk(builders ...*WorkspaceMemberCreate) *WorkspaceMemberCreateBulk {
	return &WorkspaceMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkspaceMemberClient) MapCreateBulk(slice any, setFunc func(*WorkspaceMemberCreate, int)) *WorkspaceMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkspaceMemberCreateBulk{err: fmt.Errorf("calling to WorkspaceMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkspaceMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkspaceMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkspaceMember.
func (c *WorkspaceMemberClient) Update() *WorkspaceMemberUpdate {
	mutation := newWorkspaceMemberMutation(c.config, OpUpdate)
	return &WorkspaceMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkspaceMemberClient) UpdateOne(_m *WorkspaceMember) *WorkspaceMemberUpdateOne {
	mutation := newWorkspaceMemberMutation(c.config, OpUpdateOne, withWorkspaceMember(_m))
	return &WorkspaceMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkspaceMemberClient) UpdateOneID(id uuid.UUID) *WorkspaceMemberUpdateOne {
	mutation := newWorkspaceMemberMutation(c.config, OpUpdateOne, withWorkspaceMemberID(id))
	return &WorkspaceMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkspaceMember.
func (c *WorkspaceMemberClient) Delete() *WorkspaceMemberDelete {
	mutation := newWorkspaceMemberMutation(c.config, OpDelete)
	return &WorkspaceMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkspaceMemberClient) DeleteOne(_m *WorkspaceMember) *WorkspaceMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkspaceMemberClient) DeleteOneID(id uuid.UUID) *WorkspaceMemberDeleteOne {
	builder := c.Delete().Where(workspacemember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkspaceMemberDeleteOne{builder}
}

// Query returns a query builder for WorkspaceMember.
func (c *WorkspaceMemberClient) Query() *WorkspaceMemberQuery {
	return &WorkspaceMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkspaceMember},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkspaceMember entity by its id.
func (c *WorkspaceMemberClient) Get(ctx context.Context, id uuid.UUID) (*WorkspaceMember, error) {
	return c.Query().Where(workspacemember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkspaceMemberClient) GetX(ctx context.Context, id uuid.UUID) *WorkspaceMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkspace queries the workspace edge of a WorkspaceMember.
func (c *WorkspaceMemberClient) QueryWorkspace(_m *WorkspaceMember) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspacemember.Table, workspacemember.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workspacemember.WorkspaceTable, workspacemember.WorkspaceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a WorkspaceMember.
func (c *WorkspaceMemberClient) QueryUser(_m *WorkspaceMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspacemember.Table, workspacemember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workspacemember.UserTable, workspacemember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkspaceMemberClient) Hooks() []Hook {
	return c.hooks.WorkspaceMember
}

// Interceptors returns the client interceptors.
func (c *WorkspaceMemberClient) Interceptors() []Interceptor {
	return c.inters.WorkspaceMember
}

func (c *WorkspaceMemberClient) mutate(ctx context.Context, m *WorkspaceMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkspaceMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkspaceMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkspaceMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkspaceMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkspaceMember mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Attachment, Channel, ChannelMember, ChannelReadState, Message, MessageBookmark,
		MessageGroupMention, MessageLink, MessageReaction, MessageUserMention, Session,
		ThreadMetadata, User, UserGroup, UserGroupMember, Workspace,
		WorkspaceMember []ent.Hook
	}
	inters struct {
		Attachment, Channel, ChannelMember, ChannelReadState, Message, MessageBookmark,
		MessageGroupMention, MessageLink, MessageReaction, MessageUserMention, Session,
		ThreadMetadata, User, UserGroup, UserGroupMember, Workspace,
		WorkspaceMember []ent.Interceptor
	}
)
